/* --- Generated by genom 2.99.29. Do not edit -------------------------- */

#include "autoconf/acheader.h"

#include "commonStructLib.h"

#include "camera_control_task.h"



/* --- task film -------------------------------------------------------- */

/* state start */
static __inline__ genom_event
camera_codel_task_film_start(
  struct genom_component_data *self, struct genom_activity *activity)
{
  (void)activity; /* fix -Wunused-parameter */
  genom_event s;

  genom_take_resource(
    self,
    self->resources.control == genom_camera_GetCurrentPosition_controlcb ||
    self->resources.control == genom_camera_GetCurrentMap_controlcb ||
    self->resources.control == genom_camera_GetCurrentArena_controlcb ||
    self->resources.all,

    self->resources.task_film = InitMoveParameters);
  s = InitMoveParameters(&(self->ids.image), &(self->ids.arene), &(self->ids.position), &self->tasks.film.context);
  genom_give_resource(self, self->resources.task_film = NULL);

  return s;
}

/* invoke codels according to film state */
static __inline__ enum genom_activity_status
camera_invoke_task_film(
  struct genom_component_data *self, struct genom_activity *a)
{
  genom_event s;

  genom_log_debug(
    "task film invoking task film %s", a->state);

  if (a->state == camera_start) {
    s = camera_codel_task_film_start(self, a);
    genom_log_debug("task film yielded %s", s);
    if (
      0) {
      a->state = s;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = s;
      a->pause = 1;
      return ACT_RUN;
    }
    if (
      s == camera_ether ||
      0) {
      a->state = camera_ether;
      return ACT_ETHER;
    }
    goto ex;
  }

  /* default start, if not already handled above */
  if (a->state == camera_start) {
    a->state = camera_ether;
    return ACT_ETHER;
  }

  /* default stop, if not already handled above */
  if (a->state == camera_stop) {
    genom_interrupted_detail d;

    assert(a->interruptedby);
    strncpy(d.by, a->interruptedby, sizeof(d.by));
    d.by[sizeof(d.by)-1] = *"";
    s = genom_interrupted(&d, &self->tasks.film.context);
    goto ex;
  }

  /* this cannot happen by construction */
  genom_log_warn(0, "bad state (%s) in task_film",
                 a->state?a->state : "genom_ok");
  abort();
  /*NOTREACHED*/

ex:
  if (
    s != genom_incompatible_digest_id &&
    s != genom_bad_transition_id &&
    s != genom_interrupted_id &&
    s != genom_serialization_id &&
    s != genom_too_many_activities_id &&
    s != genom_disallowed_id &&
    s != genom_mwerr_id &&
    1) {
    genom_bad_transition_detail d;
    strncpy(d.from, a->state, sizeof(d.from)); d.from[sizeof(d.from)-1] = *"";
    strncpy(d.to, s, sizeof(d.to)); d.to[sizeof(d.to)-1] = *"";
    genom_log_warn(
      0, "bad transition from %s to %s in task film",
      a->state, s?s:"genom_ok");
    genom_bad_transition(&d, &self->tasks.film.context);
  }

  a->state = NULL;
  return ACT_ETHER;
}


/* --- service StartFilm ------------------------------------------------ */

/* state start */
static __inline__ genom_event
camera_codel_service_StartFilm_start(
  struct genom_component_data *self, struct genom_activity *activity)
{
  (void)activity; /* fix -Wunused-parameter */
  genom_event s;

  genom_take_resource(
    self,
    self->resources.all,

    self->resources.task_film = FilmStart);
  s = FilmStart(&(self->ids.image), &(self->ports.IM.handle), &self->tasks.film.context);
  genom_give_resource(self, self->resources.task_film = NULL);

  return s;
}

/* state calcul_pos */
static __inline__ genom_event
camera_codel_service_StartFilm_calcul_pos(
  struct genom_component_data *self, struct genom_activity *activity)
{
  (void)activity; /* fix -Wunused-parameter */
  genom_event s;

  genom_take_resource(
    self,
    self->resources.control == genom_camera_GetCurrentPosition_controlcb ||
    self->resources.control == genom_camera_GetCurrentArena_controlcb ||
    self->resources.all,

    self->resources.task_film = FilmPosition);
  s = FilmPosition(&(self->ids.image), &(self->ids.position), &(self->ids.arene), &self->tasks.film.context);
  genom_give_resource(self, self->resources.task_film = NULL);

  return s;
}

/* state write */
static __inline__ genom_event
camera_codel_service_StartFilm_write(
  struct genom_component_data *self, struct genom_activity *activity)
{
  (void)activity; /* fix -Wunused-parameter */
  genom_event s;

  genom_take_resource(
    self,
    self->resources.all,

    self->resources.task_film = FilmWrite);
  s = FilmWrite(&(self->ids.position), &(self->ids.arene), &(self->ports.AR.handle), &(self->ports.POS.handle), &self->tasks.film.context);
  genom_give_resource(self, self->resources.task_film = NULL);

  return s;
}

/* invoke codels according to StartFilm state */
static __inline__ enum genom_activity_status
camera_invoke_service_StartFilm(
  struct genom_component_data *self, struct genom_activity *a)
{
  genom_event s;

  genom_log_debug(
    "task film invoking service StartFilm %s", a->state);

  if (a->state == camera_start) {
    s = camera_codel_service_StartFilm_start(self, a);
    genom_log_debug("service StartFilm yielded %s", s);
    if (
      s == camera_calcul_pos ||
      0) {
      a->state = s;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = s;
      a->pause = 1;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = camera_ether;
      return ACT_ETHER;
    }
    goto ex;
  }

  if (a->state == camera_calcul_pos) {
    s = camera_codel_service_StartFilm_calcul_pos(self, a);
    genom_log_debug("service StartFilm yielded %s", s);
    if (
      s == camera_write ||
      0) {
      a->state = s;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = s;
      a->pause = 1;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = camera_ether;
      return ACT_ETHER;
    }
    goto ex;
  }

  if (a->state == camera_write) {
    s = camera_codel_service_StartFilm_write(self, a);
    genom_log_debug("service StartFilm yielded %s", s);
    if (
      0) {
      a->state = s;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = s;
      a->pause = 1;
      return ACT_RUN;
    }
    if (
      s == camera_ether ||
      0) {
      a->state = camera_ether;
      return ACT_ETHER;
    }
    goto ex;
  }


  /* default stop, if not already handled above */
  if (a->state == camera_stop) {
    genom_interrupted_detail d;

    assert(a->interruptedby);
    strncpy(d.by, a->interruptedby, sizeof(d.by));
    d.by[sizeof(d.by)-1] = *"";
    s = genom_interrupted(&d, &self->tasks.film.context);
    goto ex;
  }

  /* this cannot happen by construction */
  genom_log_warn(0, "bad state (%s) in service_StartFilm",
                 a->state?a->state : "genom_ok");
  abort();
  /*NOTREACHED*/

ex:
  if (
    s != genom_incompatible_digest_id &&
    s != genom_bad_transition_id &&
    s != genom_interrupted_id &&
    s != genom_serialization_id &&
    s != genom_too_many_activities_id &&
    s != genom_disallowed_id &&
    s != genom_mwerr_id &&
    s != camera_INVALID_DATA_id &&
    1) {
    genom_bad_transition_detail d;
    strncpy(d.from, a->state, sizeof(d.from)); d.from[sizeof(d.from)-1] = *"";
    strncpy(d.to, s, sizeof(d.to)); d.to[sizeof(d.to)-1] = *"";
    genom_log_warn(
      0, "bad transition from %s to %s in service StartFilm",
      a->state, s?s:"genom_ok");
    genom_bad_transition(&d, &self->tasks.film.context);
  }

  a->state = NULL;
  return ACT_ETHER;
}



/* === task film ======================================================== */

enum genom_activity_status
genom_camera_film_invoke(
  struct genom_component_data *self, struct genom_activity *a)
{
  switch(a->sid) {
    case -1:
      return camera_invoke_task_film(self, a);

    case CAMERA_StartFilm_RQSTID:
      return camera_invoke_service_StartFilm(self, a);
  }

  /* must not happen */
  genom_log_warn(0, "bad activity %d in task film", a->sid);
  abort();
  return ACT_VOID;
}

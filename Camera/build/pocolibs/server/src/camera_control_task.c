/* --- Generated by genom 2.99.29. Do not edit -------------------------- */

#include "autoconf/acheader.h"

#include <sys/types.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#include "commonStructLib.h"
#include "h2evnLib.h"
#include "taskLib.h"

#include "camera_parameters.h"
#include "camera_msglib.h"
#include "camera_activity.h"
#include "camera_control_task.h"
#include "typecopy.h"


/* --- local data ---------------------------------------------------------- */

#define CNTRL_TASK_MIN_STACK_SIZE 4096
#define EXEC_TASK_MIN_STACK_SIZE  4096

/* cslib server with context pointer, for reentrant csLib callbacks */
struct CS_SERV_IDS {
  CS_SERV csserv;
  struct genom_component_data *self;
};

static void	camera_abort_activity_rqstcb(SERV_ID csserv, int sid);
static void	camera_connect_port_rqstcb(SERV_ID csserv, int sid);
static void	camera_connect_service_rqstcb(SERV_ID csserv, int sid);
static void	camera_kill_rqstcb(SERV_ID csserv, int sid);
static void	camera_GetCurrentPosition_rqstcb(SERV_ID csserv, int sid);
static void	camera_GetCurrentMap_rqstcb(SERV_ID csserv, int sid);
static void	camera_GetCurrentArena_rqstcb(SERV_ID csserv, int sid);
static void	camera_FilmStop_rqstcb(SERV_ID csserv, int sid);
static void	camera_StartFilm_rqstcb(SERV_ID csserv, int sid);
static void *	camera_cntrl_task(void *);


/* --- genom_camera_init ------------------------------------------------ */

void *
genom_camera_init(void)
{
  struct genom_component_data *self;
  char tname[64];

  /* create internal data structure */
  self = malloc(sizeof(*self));
  if (!self) {
    genom_log_warn(1, "cannot create internal data structure");
    return NULL;
  }

  genom_tinit_t_camera_ids(&self->ids);
  genom_tinit_camera_genom_state_port(&self->ports.genom_state);
  genom_tinit_camera_genom_metadata_port(&self->ports.genom_metadata);
  genom_tinit_camera_AR_port(&self->ports.AR);
  genom_tinit_camera_POS_port(&self->ports.POS);
  genom_tinit_camera_IM_port(&self->ports.IM);

  self->tasks.film.context.raise = genom_pocolibs_raise;
  self->tasks.film.context.raised = genom_pocolibs_raised;
  self->tasks.film.context.data =
    &self->tasks.film.context_data;

  self->tasks.film.context_data.self = self;
  self->tasks.film.context_data.ex = genom_ok;
  self->tasks.film.context_data.exdetail = NULL;
  self->tasks.film.context_data.exsize = 0;

  self->tasks.film.taskid = ERROR;

  self->tasks.film.rusage.cycles = 0;
  self->tasks.film.rusage.timings.last = 0.;
  self->tasks.film.rusage.timings.max = 0.;
  self->tasks.film.rusage.timings.avg = 0.;
  self->tasks.film.rusage.load.last = 0.;
  self->tasks.film.rusage.load.max = 0.;
  self->tasks.film.rusage.load.avg = 0.;
  pthread_spin_init(&self->tasks.film.rlock, 0);

  self->tasks.film.runnable = 1;
  self->tasks.film.shutdown = 0;
  {
    size_t i;
    for(i = 0; i < genom_max_activities(); i++)
      self->tasks.film.activities.a[i].any.status = ACT_VOID;
    i = genom_camera_activity_alloc(&self->tasks.film.activities);
    assert(i == 0);
    self->tasks.film.permanent =
      &self->tasks.film.activities.a[i].any;
  }
  self->tasks.film.permanent->sid = -1;
  self->tasks.film.permanent->rid = -1;
  self->tasks.film.permanent->status = ACT_INIT;
  self->tasks.film.permanent->start = 1;

  pthread_mutex_init(&self->tasks.film.lock, NULL);
  pthread_cond_init(&self->tasks.film.sync, NULL);

  self->control.context.raise = genom_pocolibs_raise;
  self->control.context.raised = genom_pocolibs_raised;

  self->control.context.data = &self->control.context_data;
  self->control.context_data.self = self;
  self->control.context_data.ex = genom_ok;
  self->control.context_data.exdetail = NULL;
  self->control.context_data.exsize = 0;

  self->control.taskid = ERROR;
  snprintf(self->control.mbox_name, sizeof(self->control.mbox_name),
           "%s", genom_instance);
  self->control.csserv = NULL;
  self->control.shutdown = 0;
  self->control.activity.any.status = ACT_VOID;
  memset(self->control.run_map, 0, sizeof(self->control.run_map));
  pthread_spin_init(&self->control.rlock, 0);
  pthread_mutex_init(&self->control.lock, NULL);
  pthread_cond_init(&self->control.sync, NULL);

  self->resources.all = 0;
  self->resources.control = NULL;
  self->resources.task_film = NULL;
  self->resources.q = 0;
  self->resources.qnext = 0;
  pthread_mutex_init(&self->resources.lock, NULL);
  pthread_cond_init(&self->resources.sync, NULL);

  /* create posters */
  if (genom_metadata_camera_init(self)) goto error;
  if (genom_state_camera_init(self)) goto error;
  if (genom_camera_genom_state_open(&self->control.context)) goto error;
  if (genom_camera_genom_metadata_open(&self->control.context)) goto error;
  if (genom_camera_AR_open(&self->control.context)) goto error;
  if (genom_camera_POS_open(&self->control.context)) goto error;
  if (genom_camera_IM_open(&self->control.context)) goto error;
  if (genom_camera_genom_metadata_write(&self->control.context)) goto error;
  if (genom_camera_genom_state_write(&self->control.context)) goto error;

  /* spawn film task */
  snprintf(tname, sizeof(tname), "%s/%s", genom_instance, "film");
  pthread_mutex_lock(&self->tasks.film.lock);
  self->tasks.film.taskid =
    taskSpawn2(tname, 255,
               VX_FP_TASK, EXEC_TASK_MIN_STACK_SIZE + 8388608,
               genom_camera_film_exec_task, self);
  while (self->tasks.film.taskid != ERROR &&
         self->tasks.film.permanent->start)
    pthread_cond_wait(&self->tasks.film.sync,
                      &self->tasks.film.lock);

  genom_state_camera_update(self, &self->tasks.film.activities,
    camera_film_TASKID);
  if (self->tasks.film.taskid == ERROR) {
    genom_log_warn(1, "cannot spawn %s exec task", "film");
    pthread_mutex_unlock(&self->tasks.film.lock);
    goto error;
  }
  if (self->tasks.film.permanent->status == ACT_ETHER &&
      self->tasks.film.permanent->state != camera_ether) {
    genom_log_warn(0, "%s exec task failed", "film");
    pthread_mutex_unlock(&self->tasks.film.lock);
    goto error;
  }
  pthread_mutex_unlock(&self->tasks.film.lock);
  genom_state_camera_refresh(self);


  /* spawn control task */
  snprintf(tname, sizeof(tname), "%s", genom_instance);
  pthread_mutex_lock(&self->control.lock);
  if (taskSpawn2(tname, 10 /* priority */,
                 VX_FP_TASK, CAMERA_MAX_RQST_SIZE + CAMERA_MAX_REPLY_SIZE
                 + CNTRL_TASK_MIN_STACK_SIZE /*size*/,
                 camera_cntrl_task, self) == ERROR) {
    genom_log_warn(1, "cannot spawn control task");
    pthread_mutex_unlock(&self->control.lock);
    goto error;
  }
  while (self->control.taskid == ERROR)
    pthread_cond_wait(&self->control.sync, &self->control.lock);
  if (self->control.taskid == 0) {
    self->control.taskid = ERROR;
    pthread_mutex_unlock(&self->control.lock);
    goto error;
  }
  pthread_mutex_unlock(&self->control.lock);

  genom_log_info("setup and running");
  return self;

error:
  genom_camera_fini(self);
  return NULL;
}


/* --- genom_camera_fini ------------------------------------------------ */

void
genom_camera_fini(void *data)
{
  struct genom_component_data *self = data;

  /* interrupt & wait for all regular activities */
  if (self->tasks.film.taskid != ERROR) {
    struct genom_activity *a;
    int delay;
    size_t id;

    genom_log_debug("interrupting task film activities");
    pthread_mutex_lock(&self->tasks.film.lock);
    do {
      delay = 0;
      for(id = 0; id < genom_max_activities(); id++) {
        a = &self->tasks.film.activities.a[id].any;
        if (a == self->tasks.film.permanent) continue;

        if (a->status == ACT_INIT || a->status == ACT_RUN) {
          if (!a->stop) {
            a->stop = 1;
            a->interruptedby = "kill";
            if (!self->tasks.film.runnable) {
              self->tasks.film.runnable = 1;
              pthread_cond_broadcast(&self->tasks.film.sync);
            }
          }
          delay = 1;
        } else if (a->status == ACT_STOP)
          delay = 1;
      }
      if (delay)
        pthread_cond_wait(&self->tasks.film.sync,
                          &self->tasks.film.lock);
    } while(delay);
    pthread_mutex_unlock(&self->tasks.film.lock);
  }

  /* interrupt permanent activities */
  if (self->tasks.film.taskid != ERROR) {
    struct genom_activity *a;

    genom_log_debug("interrupting task film");
    pthread_mutex_lock(&self->tasks.film.lock);

    a = self->tasks.film.permanent;
    if (!a) {
      /* activity was ether, realloc one */
      int i = genom_camera_activity_alloc(
        &self->tasks.film.activities);
      assert(i>=0);
      a = &self->tasks.film.activities.a[i].any;
      a->sid = a->rid = -1;
    }
    if (a->status != ACT_STOP) {
      if (a->status == ACT_ETHER) a->status = ACT_INIT;
      a->stop = 1;
      a->interruptedby = "kill";
      self->tasks.film.permanent = a;
      self->tasks.film.runnable = 1;
      pthread_cond_broadcast(&self->tasks.film.sync);
    }
    while(self->tasks.film.permanent &&
          self->tasks.film.permanent->status != ACT_ETHER)
      pthread_cond_wait(&self->tasks.film.sync,
                        &self->tasks.film.lock);

    pthread_mutex_unlock(&self->tasks.film.lock);
  }

  /* wait for exec tasks */
  genom_log_debug("waiting task film");
  pthread_mutex_lock(&self->tasks.film.lock);
  self->tasks.film.shutdown = 1;
  self->tasks.film.runnable = 1;
  pthread_cond_broadcast(&self->tasks.film.sync);
  while (self->tasks.film.taskid != ERROR) {
    pthread_cond_wait(&self->tasks.film.sync,
                      &self->tasks.film.lock);
  }
  pthread_mutex_unlock(&self->tasks.film.lock);


  /* wait for control task */
  if (self->control.taskid != ERROR) {
    genom_log_debug("waiting control task");
    pthread_mutex_lock(&self->control.lock);
    self->control.shutdown = 1;
    while (self->control.taskid != 0) {
      genom_camera_schedule_cntrl(self);
      pthread_cond_wait(&self->control.sync, &self->control.lock);
    }
    pthread_mutex_unlock(&self->control.lock);
  }

  /* clean up */
  genom_camera_genom_state_delete(&self->control.context);
  genom_camera_genom_metadata_delete(&self->control.context);
  genom_camera_AR_delete(&self->control.context);
  genom_camera_POS_delete(&self->control.context);
  genom_camera_IM_delete(&self->control.context);

  genom_tfini_camera_genom_state_port(&self->ports.genom_state);
  genom_tfini_camera_genom_metadata_port(&self->ports.genom_metadata);
  genom_tfini_camera_AR_port(&self->ports.AR);
  genom_tfini_camera_POS_port(&self->ports.POS);
  genom_tfini_camera_IM_port(&self->ports.IM);
  genom_tfini_t_camera_ids(&self->ids);
  free(self);
  genom_log_info("shutdown complete");
}


/* --- genom_camera_schedule_cntrl -------------------------------------- */

void
genom_camera_schedule_cntrl(struct genom_component_data *self)
{
  if (self->control.taskid == ERROR) return;
  h2evnSignal(self->control.taskid);
}


/* --- camera_cntrl_task(void) ------------------------------------------ */

static void *
camera_cntrl_task(void *data)
{
  struct genom_component_data *self = data;
  int e;

  /* create requests reception mailbox */
  if (csMboxInit(self->control.mbox_name, CAMERA_MBOX_RQST_SIZE, 0) != OK) {
    genom_log_warn(1, "cannot create server mailbox");
    pthread_mutex_lock(&self->control.lock);
    self->control.taskid = 0;
    pthread_cond_broadcast(&self->control.sync);
    pthread_mutex_unlock(&self->control.lock);
    return NULL;
  }

  /* configure as a server */
  if (csServInitN(
	CAMERA_MAX_RQST_SIZE,
	CAMERA_MAX_REPLY_SIZE >= CAMERA_MAX_INTERMED_REPLY_SIZE ?
	CAMERA_MAX_REPLY_SIZE : CAMERA_MAX_INTERMED_REPLY_SIZE,
	CAMERA_NRQSTID, &self->control.csserv) != OK) {
    genom_log_warn(1, "cannot initialize server mailbox");
    goto error;
  }
  /* fiddle with returned CS_SERV structure, to store ids for callbacks */
  self->control.csserv =
    realloc(self->control.csserv, sizeof(struct CS_SERV_IDS));
  ((struct CS_SERV_IDS *)self->control.csserv)->self = self;

  /* install services callbacks */
  if (csServFuncInstall(self->control.csserv, CAMERA_abort_activity_RQSTID,
                        (FUNCPTR)camera_abort_activity_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service abort_activity");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, CAMERA_connect_port_RQSTID,
                        (FUNCPTR)camera_connect_port_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service connect_port");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, CAMERA_connect_service_RQSTID,
                        (FUNCPTR)camera_connect_service_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service connect_service");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, CAMERA_kill_RQSTID,
                        (FUNCPTR)camera_kill_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service kill");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, CAMERA_GetCurrentPosition_RQSTID,
                        (FUNCPTR)camera_GetCurrentPosition_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service GetCurrentPosition");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, CAMERA_GetCurrentMap_RQSTID,
                        (FUNCPTR)camera_GetCurrentMap_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service GetCurrentMap");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, CAMERA_GetCurrentArena_RQSTID,
                        (FUNCPTR)camera_GetCurrentArena_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service GetCurrentArena");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, CAMERA_FilmStop_RQSTID,
                        (FUNCPTR)camera_FilmStop_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service FilmStop");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, CAMERA_StartFilm_RQSTID,
                        (FUNCPTR)camera_StartFilm_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service StartFilm");
    goto error;
  }

  /* signal parent */
  genom_log_info("spawned control task");
  pthread_mutex_lock(&self->control.lock);
  self->control.taskid = taskIdSelf();
  pthread_cond_broadcast(&self->control.sync);
  pthread_mutex_unlock(&self->control.lock);

  do {
    if (self->control.shutdown) {
      /* the task must sleep with h2evnSusp(), so there is no way to atomically
       * check for the shutdown flag. So do not bother taking the mutex.
       * The genom_camera_fini() function will signal an h2evn, after
       * setting the shutdown flag, so it shouldn't exist any race. */
      break;
    }

    /* read reception mailbox status and sleep if there is no message */
    e = csMboxStatus(RCV_MBOX);
    switch(e) {
      case 0: /* no message */
        /* update state port before sleeping */
        genom_state_camera_refresh(self);

        e = h2evnSusp(0);
        if (e != TRUE) {
          genom_log_warn(1, "someone did something nasty");
          genom_log_warn(0, "aborting");
          abort();
        }
        genom_log_debug("control task wake up");

        /* update reception mailbox status */
        e = csMboxStatus(RCV_MBOX);
        if (e != RCV_MBOX) /* awoken by internal event */ break;

        /*FALLTHROUGH*/
      case RCV_MBOX: /* incoming request */
        if (csServRqstExec(self->control.csserv) != OK) {
          genom_log_warn(1, "cannot read reception mailbox");
          genom_log_warn(0, "aborting");
          abort();
        }
        break;

      case ERROR:
        genom_log_warn(1, "cannot check reception mailbox");
        genom_log_warn(0, "aborting");
        abort();
    }


    /* process pending activities */
    pthread_mutex_lock(&self->tasks.film.lock);
    {
      struct genom_activity *a;
      size_t id;

      for(id = 0; id < genom_max_activities(); id++) {
        a = &self->tasks.film.activities.a[id].any;
        switch(a->status) {
          case ACT_VOID: case ACT_RUN: case ACT_STOP: continue;

          case ACT_INIT: {
            int delay;
            if (!a->start) {
              pthread_mutex_unlock(&self->tasks.film.lock);
              delay = genom_camera_interrupt_reqd(self, a);
              pthread_mutex_lock(&self->tasks.film.lock);
              if (!delay) {
                a->start = 1;
                if (!self->tasks.film.runnable) {
                  self->tasks.film.runnable = 1;
                  pthread_cond_broadcast(&self->tasks.film.sync);
                }
              }
            }
            break;
          }

          case ACT_ETHER:
            if (a == self->tasks.film.permanent)
              self->tasks.film.permanent = NULL;
            else {
              pthread_mutex_unlock(&self->tasks.film.lock);
              genom_camera_activity_report(self, a);
              pthread_mutex_lock(&self->tasks.film.lock);
            }
            a->status = ACT_VOID;
            genom_state_camera_update(
              self, &self->tasks.film.activities,
              camera_film_TASKID);
            break;
        }
      }
    }
    pthread_mutex_unlock(&self->tasks.film.lock);
  } while(1);

  genom_log_info("shutting down control task");

error:
  if (self->control.csserv) csServEnd(self->control.csserv);
  csMboxEnd();

  pthread_mutex_lock(&self->control.lock);
  self->control.taskid = 0;
  pthread_cond_broadcast(&self->control.sync);
  pthread_mutex_unlock(&self->control.lock);
  return NULL;
}


/* --- Service callbacks --------------------------------------------------- */


static void
camera_abort_activity_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_camera_abort_activity_activity *a;
  STATUS s;

  genom_log_debug("handling request for abort_activity");

  /* get an activity slot */
  a = &self->control.activity.s_abort_activity;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = CAMERA_abort_activity_RQSTID;
  a->h.rid = rid;
  genom_tinit_camera_abort_activity_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_camera_abort_activity_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "abort_activity");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_camera_abort_activity_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.film.lock);
  if (!self->tasks.film.runnable) {
    self->tasks.film.runnable = 1;
    pthread_cond_broadcast(&self->tasks.film.sync);
  }
  pthread_mutex_unlock(&self->tasks.film.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_camera_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[CAMERA_abort_activity_RQSTID] = 1;

  /* send final reply */
  a->h.state = camera_ether;
  genom_camera_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
camera_connect_port_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_camera_connect_port_activity *a;
  STATUS s;

  genom_log_debug("handling request for connect_port");

  /* get an activity slot */
  a = &self->control.activity.s_connect_port;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = CAMERA_connect_port_RQSTID;
  a->h.rid = rid;
  genom_tinit_camera_connect_port_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_camera_connect_port_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "connect_port");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_camera_connect_port_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.film.lock);
  if (!self->tasks.film.runnable) {
    self->tasks.film.runnable = 1;
    pthread_cond_broadcast(&self->tasks.film.sync);
  }
  pthread_mutex_unlock(&self->tasks.film.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_camera_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[CAMERA_connect_port_RQSTID] = 1;

  /* send final reply */
  a->h.state = camera_ether;
  genom_camera_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
camera_connect_service_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_camera_connect_service_activity *a;
  STATUS s;

  genom_log_debug("handling request for connect_service");

  /* get an activity slot */
  a = &self->control.activity.s_connect_service;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = CAMERA_connect_service_RQSTID;
  a->h.rid = rid;
  genom_tinit_camera_connect_service_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_camera_connect_service_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "connect_service");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_camera_connect_service_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.film.lock);
  if (!self->tasks.film.runnable) {
    self->tasks.film.runnable = 1;
    pthread_cond_broadcast(&self->tasks.film.sync);
  }
  pthread_mutex_unlock(&self->tasks.film.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_camera_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[CAMERA_connect_service_RQSTID] = 1;

  /* send final reply */
  a->h.state = camera_ether;
  genom_camera_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
camera_kill_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_camera_kill_activity *a;
  STATUS s;

  genom_log_debug("handling request for kill");

  /* get an activity slot */
  a = &self->control.activity.s_kill;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = CAMERA_kill_RQSTID;
  a->h.rid = rid;
  genom_tinit_camera_kill_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_camera_kill_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "kill");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_camera_kill_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.film.lock);
  if (!self->tasks.film.runnable) {
    self->tasks.film.runnable = 1;
    pthread_cond_broadcast(&self->tasks.film.sync);
  }
  pthread_mutex_unlock(&self->tasks.film.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_camera_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[CAMERA_kill_RQSTID] = 1;

  /* send final reply */
  a->h.state = camera_ether;
  genom_camera_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
camera_GetCurrentPosition_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_camera_GetCurrentPosition_activity *a;
  STATUS s;

  genom_log_debug("handling request for GetCurrentPosition");

  /* get an activity slot */
  a = &self->control.activity.s_GetCurrentPosition;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = CAMERA_GetCurrentPosition_RQSTID;
  a->h.rid = rid;
  genom_tinit_camera_GetCurrentPosition_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_camera_GetCurrentPosition_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "GetCurrentPosition");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_camera_GetCurrentPosition_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.film.lock);
  if (!self->tasks.film.runnable) {
    self->tasks.film.runnable = 1;
    pthread_cond_broadcast(&self->tasks.film.sync);
  }
  pthread_mutex_unlock(&self->tasks.film.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_camera_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[CAMERA_GetCurrentPosition_RQSTID] = 1;

  /* send final reply */
  a->h.state = camera_ether;
  genom_camera_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
camera_GetCurrentMap_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_camera_GetCurrentMap_activity *a;
  STATUS s;

  genom_log_debug("handling request for GetCurrentMap");

  /* get an activity slot */
  a = &self->control.activity.s_GetCurrentMap;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = CAMERA_GetCurrentMap_RQSTID;
  a->h.rid = rid;
  genom_tinit_camera_GetCurrentMap_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_camera_GetCurrentMap_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "GetCurrentMap");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_camera_GetCurrentMap_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.film.lock);
  if (!self->tasks.film.runnable) {
    self->tasks.film.runnable = 1;
    pthread_cond_broadcast(&self->tasks.film.sync);
  }
  pthread_mutex_unlock(&self->tasks.film.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_camera_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[CAMERA_GetCurrentMap_RQSTID] = 1;

  /* send final reply */
  a->h.state = camera_ether;
  genom_camera_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
camera_GetCurrentArena_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_camera_GetCurrentArena_activity *a;
  STATUS s;

  genom_log_debug("handling request for GetCurrentArena");

  /* get an activity slot */
  a = &self->control.activity.s_GetCurrentArena;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = CAMERA_GetCurrentArena_RQSTID;
  a->h.rid = rid;
  genom_tinit_camera_GetCurrentArena_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_camera_GetCurrentArena_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "GetCurrentArena");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_camera_GetCurrentArena_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.film.lock);
  if (!self->tasks.film.runnable) {
    self->tasks.film.runnable = 1;
    pthread_cond_broadcast(&self->tasks.film.sync);
  }
  pthread_mutex_unlock(&self->tasks.film.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_camera_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[CAMERA_GetCurrentArena_RQSTID] = 1;

  /* send final reply */
  a->h.state = camera_ether;
  genom_camera_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
camera_FilmStop_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_camera_FilmStop_activity *a;
  STATUS s;

  genom_log_debug("handling request for FilmStop");

  /* get an activity slot */
  a = &self->control.activity.s_FilmStop;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = CAMERA_FilmStop_RQSTID;
  a->h.rid = rid;
  genom_tinit_camera_FilmStop_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_camera_FilmStop_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "FilmStop");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_camera_FilmStop_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.film.lock);
  if (!self->tasks.film.runnable) {
    self->tasks.film.runnable = 1;
    pthread_cond_broadcast(&self->tasks.film.sync);
  }
  pthread_mutex_unlock(&self->tasks.film.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_camera_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[CAMERA_FilmStop_RQSTID] = 1;

  /* send final reply */
  a->h.state = camera_ether;
  genom_camera_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
camera_StartFilm_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_camera_StartFilm_activity *a;
  STATUS s;

  genom_log_debug("handling request for StartFilm");

  /* get an activity slot */
  pthread_mutex_lock(&self->tasks.film.lock);
  int id = genom_camera_activity_alloc(&self->tasks.film.activities);
  if (id < 0) {
    pthread_mutex_unlock(&self->tasks.film.lock);
    s = csServReplySend(
      csserv, rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_camera_genom_too_many_activities_encodex);
    if (s == ERROR) assert(!"unexpected failure");
    return;
  }
  a = &self->tasks.film.activities.a[id].s_StartFilm;
  pthread_mutex_unlock(&self->tasks.film.lock);
  a->h.sid = CAMERA_StartFilm_RQSTID;
  a->h.rid = rid;
  genom_tinit_camera_StartFilm_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_camera_StartFilm_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "StartFilm");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_camera_StartFilm_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.film.lock);
  if (!self->tasks.film.runnable) {
    self->tasks.film.runnable = 1;
    pthread_cond_broadcast(&self->tasks.film.sync);
  }
  pthread_mutex_unlock(&self->tasks.film.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_camera_activity_report(self, &a->h);
    goto clean;
  }

  /* update state port */
  pthread_mutex_lock(&self->tasks.film.lock);
  genom_state_camera_update(
              self, &self->tasks.film.activities,
              camera_film_TASKID);
  pthread_mutex_unlock(&self->tasks.film.lock);

  /* send intermediate reply */
  s = csServReplySend(csserv, rid, INTERMED_REPLY, OK,
                      (char *)&a->h.aid, sizeof(int), NULL);
  if (s == ERROR) {
    genom_log_warn(1, "cannot acknowledge service %s", "StartFilm");
  }

  return;

clean:
  assert(a->h.status == ACT_INIT);
  pthread_mutex_lock(&self->tasks.film.lock);
  a->h.status = ACT_VOID;
  pthread_mutex_unlock(&self->tasks.film.lock);
}


/* eof */

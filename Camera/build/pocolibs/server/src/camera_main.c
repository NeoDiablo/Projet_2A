/* --- Generated by genom 2.99.29. Do not edit -------------------------- */

#include "autoconf/acheader.h"

#include <sys/stat.h>
#include <sys/types.h>
#include <sys/utsname.h>
#include <assert.h>
#include <fcntl.h>
#include <getopt.h>
#include <libgen.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "portLib.h"
#include "h2devLib.h"
#include "h2initGlob.h"

#include "camera_control_task.h"


/* --- global data --------------------------------------------------------- */

const char *genom_instance = "camera";
size_t camera_varmsg_maxsize = 32768;


/* --- local data ---------------------------------------------------------- */

/* options */
static const char usage_string[] = "\
  -b,--background   daemonize\n\
  -f,--force        bypass multiple component instances detection\n\
  -i,--name=string  set component instance name\n\
     --maxmsg=size  set maximum message size in kB\n\
     --version      display camera version number\n\
  -d,--debug        log extra debugging information on stderr\n\
  -h,--help         print usage summary (this text)\n\
";
static const char shortopts_string[] = "+bfi:dh";
static struct option longopts_list[] = {
  { "background",	no_argument,		NULL,	'b'},
  { "force",		no_argument,		NULL,	'f'},
  { "name",		required_argument,	NULL,	'i'},
  { "maxmsg",		required_argument,	NULL,	-'m'},
  { "version",		no_argument,		NULL,	-'v'},
  { "debug",		no_argument,		NULL,	'd'},
  { "help",		no_argument,		NULL,	'h'},
  { NULL, 0, NULL, 0}
};

static int force = 0;
static int debug = 0;

static void	genom_camera_run(void);
static void	genom_camera_vacuum(const char *pidfile);
static void	usage(FILE *channel, char *argv0);


/* --- main ---------------------------------------------------------------- */

/** Initialization and startup
 */
int
main(int argc, char **argv)
{
  char *e;
  int c;
  int daemonize = 0;

  /* parse command line options */
  while (
    (c = getopt_long(argc, argv, shortopts_string, longopts_list, NULL)) != -1)
    switch (c) {
      case 0: break;

      case 'b': daemonize++; break;
      case 'f': force++; break;
      case 'd': debug++; break;
      case 'i': genom_instance = optarg; break;

      case -'m': {
        unsigned long s = strtoul(optarg, &e, 0);
        if (*e != 0 || s <= 0) {
          genom_log_warn(0, "bad message size: %s", optarg);
          exit(1);
        }
        camera_varmsg_maxsize = s * 1024;
        break;
      }

      case -'v': puts("1.0"); exit(0); break;
      case 'h':  usage(stdout, argv[0]);  exit(0); break;

      case '?':
      default:
	usage(stderr, argv[0]);
        exit(1);
        break;
    }
  argc -= optind;
  argv += optind;
  if (argc > 0) {
    usage(stderr, argv[0]);
    exit(1);
  }

  /* daemonize */
  if (daemonize) {
    sigset_t sset, oset;

    sigemptyset(&sset);
    sigaddset(&sset, SIGUSR1);
    sigprocmask(SIG_BLOCK, &sset, NULL);

    switch(fork()) {
      case -1:
        perror("cannot fork");
        exit(2);

      case 0: /* child */ {
        int fd;

        sigprocmask(SIG_SETMASK, &oset, NULL);

        if (setsid() == -1) exit(-1);
        if (chdir("/")) { /*nop*/; }

        fd = open("/dev/null", O_RDWR, 0);
        if (fd != -1) {
          (void)dup2(fd, STDIN_FILENO);
          if (fd > STDERR_FILENO)
            (void)close(fd);
        }
		signal(SIGUSR1, SIG_IGN);
        break;
      }

      default: /* parent */ {
        int sig = 0;

        do { sigwait(&sset, &sig); } while (sig == 0);
        assert(sig == SIGUSR1);
        _exit(0);
      }
    }
  }

  genom_camera_run();
  return 0;
}


/* --- camera_run ------------------------------------------------------- */

static void
genom_camera_run(void)
{
  struct utsname uts;
  void *camera_self;
  char pid_file_path[PATH_MAX];
  int pid_file_fd;
  FILE *pid_file;
  char *pid_dir;
  sigset_t sset;
  sig_t handler;
  STATUS s;
  int sig;

  /* block termination signals for all threads */
  sigemptyset(&sset);
  sigaddset(&sset, SIGINT);
  sigaddset(&sset, SIGQUIT);
  sigaddset(&sset, SIGTERM);

  /* block SIGUSR{1, 2} and SIGCHLD too for codel purpose 
   * XXX until a better solution is found
   * */
  sigaddset(&sset, SIGUSR1);
  sigaddset(&sset, SIGUSR2);
  sigaddset(&sset, SIGCHLD);

  pthread_sigmask(SIG_BLOCK, &sset, NULL);

  /* initialize comLib environnement */
  s = h2initGlob(10);
  if (s == ERROR) {
    genom_log_warn(1, "h2initGlob error");
    exit(2);
  }

  /* create pid file */
  pid_dir = getenv("H2DEV_DIR");
  if (!pid_dir) pid_dir = getenv("HOME");
  if (!pid_dir) pid_dir = "/tmp";
  assert(pid_dir);

  if (uname(&uts)) {
    genom_log_warn(-1, "uname");
    exit(2);
  }

  snprintf(pid_file_path, PATH_MAX, "%s/.%s.pid-%s",
           pid_dir, genom_instance, uts.nodename);
  pid_file_fd = open(pid_file_path, O_CREAT|O_EXCL|O_WRONLY, 0644);
  if (pid_file_fd < 0) {
    if (force && errno == EEXIST) {
      genom_log_warn(-1, "error creating %s", pid_file_path);
      genom_log_info("forcibly disabling the protection against duplicate"
                     " instances");
      genom_camera_vacuum(pid_file_path);
      pid_file_fd = open(pid_file_path, O_CREAT|O_EXCL|O_WRONLY, 0644);
    }
    if (pid_file_fd < 0) {
      genom_log_warn(-1, "error creating %s", pid_file_path);
      exit(2);
    }
  }

  pid_file = fdopen(pid_file_fd, "w");
  if (!pid_file) {
    genom_log_warn(-1, "error opening %s", pid_file_path);
    exit(2);
  }
  fprintf(pid_file, "%d\n", getpid());
  fclose(pid_file);

  /* initialize component */
  camera_self = genom_camera_init();
  if (!camera_self) {
    genom_log_warn(0, "initialization failed");
    unlink(pid_file_path);
    exit(2);
  }

  /* 
   * If SIGUSR1 is set to SIG_IGN, it can be two things:
   *   - the parent really ignores it, so it won't care about it
   *   - the parent want to significate that it have a special handler to deal
   *   with it. In this case, it is valuable to send it. It is in particular
   *   true in the case of the daemon mode.
   */
  handler = signal(SIGUSR1, SIG_IGN);
  if (handler == SIG_IGN)
	  kill(getppid(), SIGUSR1);
  signal(SIGUSR1, handler);

  /* we don't want to wait for codel-level signal */
  sigdelset(&sset, SIGUSR1);
  sigdelset(&sset, SIGUSR2);
  sigdelset(&sset, SIGCHLD);

  /* wait for apocalypse */
  /* For some obscure reasons, Mac OSX SL sigwait can return with sig == 0 */
  sig = 0;
  do { sigwait(&sset, &sig); } while (sig == 0);

  genom_log_info("terminating on %s signal request", strsignal(sig));
  genom_camera_fini(camera_self);
  unlink(pid_file_path);
}


/* --- genom_camera_vacuum ---------------------------------------------- */

static void
genom_camera_vacuum(const char *pidfile)
{
  char n[H2_DEV_MAX_NAME];

  if (unlink(pidfile))
    genom_log_warn(-1, "error unlinking %s", pidfile);

  snprintf(n, sizeof(n), "%s/*", genom_instance);
  genom_log_info("cleaning pocolibs %s device", genom_instance);
  h2devClean(genom_instance);
  genom_log_info("cleaning pocolibs %s devices", n);
  h2devClean(n);
}


/* --- usage --------------------------------------------------------------- */

/** Print usage on a channel.
 *
 * \param[in] channel	Output channel
 * \param[in] argv0	Program invocation name
 */

static void
usage(FILE *channel, char *argv0)
{
  fprintf(channel,
	  "camera 1.0 GenoM component\n\nUsage:\n"
	  "  %1$s [-i name] [--maxmsg size] [-f] [-b] [-d]\n"
	  "  %1$s [-h|--version]\n"
	  "\n%2$s",
	  basename(argv0), usage_string);
}


/* --- log ----------------------------------------------------------------- */

void
genom_log_info(const char *format, ...)
{
  va_list va;

  printf("%s: ", genom_instance);
  va_start(va, format);
  vprintf(format, va);
  va_end(va);
  printf("\n");
}

void
genom_log_warn(int h2error, const char *format, ...)
{
  va_list va;

  fprintf(stderr, "%s: ", genom_instance);
  va_start(va, format);
  vfprintf(stderr, format, va);
  va_end(va);
  if (h2error) {
    fprintf(stderr, ": ");
    if (h2error > 0 ) h2perror(NULL); else perror(NULL);
  } else fprintf(stderr, "\n");
}

void
genom_log_debug(const char *format, ...)
{
  va_list va;
  if (!debug) return;

  fprintf(stderr, "%s: ", genom_instance);
  va_start(va, format);
  vfprintf(stderr, format, va);
  va_end(va);
  fprintf(stderr, "\n");
}

/* --- Generated by genom 2.99.29. Do not edit -------------------------- */

#include "autoconf/acheader.h"

#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>

#include "h2devLib.h"

#include "camera_control_task.h"
#include "camera_portlib.h"
#include "serialize.h"

/* --- local data ---------------------------------------------------------- */

enum {
  camera_PORTLIB_MIN_INDEX = 0,
  camera_genom_state_INDEX,
  camera_genom_metadata_INDEX,
  camera_AR_INDEX,
  camera_POS_INDEX,
  camera_IM_INDEX,
  camera_PORTLIB_MAX_INDEX
};

/* --- state port ---------------------------------------------------------- */

int
genom_state_camera_init(struct genom_component_data *self)
{
  genom_state_component *data = &self->ports.genom_state.h.buffer;

  /* task list */
  if (genom_sequence_reserve(&data->task, 1))
    return ENOMEM;
  {
    genom_state_task *task;
    task = &data->task._buffer[camera_film_TASKID];

    snprintf(task->name, sizeof(task->name), "%s", "film");
    task->rusage.cycles = 0;
    task->rusage.timings.last = 0;
    task->rusage.timings.max = 0;
    task->rusage.timings.avg = 0;
    task->rusage.load.last = 0;
    task->rusage.load.max = 0;
    task->rusage.load.avg = 0;
    task->activity._length = 0;
    if (genom_sequence_reserve(&task->activity, genom_max_activities()))
      return ENOMEM;
  }
  data->task._length = 1;

  /* automatic versioning - nice idea borrowed from ROS */
  strncpy(data->digest, "3a577514ec4ec06f63ebfc5e2a1afab4", sizeof(data->digest));
  strncpy(data->date, "Wed Jul 19 16:32:26 CEST 2017", sizeof(data->date));
  strncpy(data->version, "1.0", sizeof(data->version));

  genom_log_debug("initialized genom_state port");
  return 0;
}

int
genom_state_camera_update(struct genom_component_data *self,
                    struct genom_activities *activities, int tnum)
{
  genom_state_component *data = &self->ports.genom_state.h.buffer;
  genom_state_task *t = &data->task._buffer[tnum];
  struct genom_activity *a;
  const char *s;
  size_t i, j;

  for(i = j = 0; i < genom_max_activities(); i++) {
    a = &activities->a[i].any;
    if (a->status == ACT_VOID) continue;

    t->activity._buffer[j].id = a->aid;
    switch(a->sid) {
      case -1: s = "<task>"; break;
      case CAMERA_StartFilm_RQSTID: s = "StartFilm"; break;
      default: assert(!"unknown service id"); break;
    }
    snprintf(t->activity._buffer[j].name,
             sizeof(t->activity._buffer[j].name), "%s", s);
    j++;
  }
  t->activity._length = j;
  return 0;
}

genom_event
genom_state_camera_refresh(struct genom_component_data *self)
{
  genom_state_component *data = &self->ports.genom_state.h.buffer;
  genom_state_task *task;
  genom_event s;

  /* task rusage */
  task = &data->task._buffer[camera_film_TASKID];
  pthread_spin_lock(&self->tasks.film.rlock);
  task->rusage = self->tasks.film.rusage;
  pthread_spin_unlock(&self->tasks.film.rlock);

  s = self->ports.genom_state.handle.write(&self->control.context);
  if (s) genom_log_warn(0, "cannot update state port: %s", s);
  genom_log_debug("refreshed genom_state port");
  return s;
}


/* --- metadata port ------------------------------------------------------- */

int
genom_metadata_camera_init(struct genom_component_data *self)
{
  pocolibs_metadata_component *meta = &self->ports.genom_metadata.h.buffer;
  size_t l, m;

  genom_sequence_reserve(&meta->services, 9);
  l = sizeof(meta->services._buffer->name);
  m = sizeof(meta->services._buffer->digest);
  meta->services._buffer[0].rqstid = CAMERA_abort_activity_RQSTID;
  strncpy(meta->services._buffer[0].name, "abort_activity", l);
  meta->services._buffer[0].name[l-1] = 0;
  strncpy(meta->services._buffer[0].digest, "4385b2f03ea2fe81a32b92a3c0e940", m);
  meta->services._buffer[0].digest[m-1] = 0;
  meta->services._buffer[1].rqstid = CAMERA_connect_port_RQSTID;
  strncpy(meta->services._buffer[1].name, "connect_port", l);
  meta->services._buffer[1].name[l-1] = 0;
  strncpy(meta->services._buffer[1].digest, "4c1bd913585cd1265c6ad7aea00421a", m);
  meta->services._buffer[1].digest[m-1] = 0;
  meta->services._buffer[2].rqstid = CAMERA_connect_service_RQSTID;
  strncpy(meta->services._buffer[2].name, "connect_service", l);
  meta->services._buffer[2].name[l-1] = 0;
  strncpy(meta->services._buffer[2].digest, "4c1bd913585cd1265c6ad7aea00421a", m);
  meta->services._buffer[2].digest[m-1] = 0;
  meta->services._buffer[3].rqstid = CAMERA_kill_RQSTID;
  strncpy(meta->services._buffer[3].name, "kill", l);
  meta->services._buffer[3].name[l-1] = 0;
  strncpy(meta->services._buffer[3].digest, "62357408c1c53751884a1c27b10599", m);
  meta->services._buffer[3].digest[m-1] = 0;
  meta->services._buffer[4].rqstid = CAMERA_GetCurrentPosition_RQSTID;
  strncpy(meta->services._buffer[4].name, "GetCurrentPosition", l);
  meta->services._buffer[4].name[l-1] = 0;
  strncpy(meta->services._buffer[4].digest, "4a7ce31639d5e05d5e3d642b206af6f0", m);
  meta->services._buffer[4].digest[m-1] = 0;
  meta->services._buffer[5].rqstid = CAMERA_GetCurrentMap_RQSTID;
  strncpy(meta->services._buffer[5].name, "GetCurrentMap", l);
  meta->services._buffer[5].name[l-1] = 0;
  strncpy(meta->services._buffer[5].digest, "fc57e3ba53274515a776b67d2eda0e8", m);
  meta->services._buffer[5].digest[m-1] = 0;
  meta->services._buffer[6].rqstid = CAMERA_GetCurrentArena_RQSTID;
  strncpy(meta->services._buffer[6].name, "GetCurrentArena", l);
  meta->services._buffer[6].name[l-1] = 0;
  strncpy(meta->services._buffer[6].digest, "9ff443adc235e91e47b553fa5bbf", m);
  meta->services._buffer[6].digest[m-1] = 0;
  meta->services._buffer[7].rqstid = CAMERA_FilmStop_RQSTID;
  strncpy(meta->services._buffer[7].name, "FilmStop", l);
  meta->services._buffer[7].name[l-1] = 0;
  strncpy(meta->services._buffer[7].digest, "62357408c1c53751884a1c27b10599", m);
  meta->services._buffer[7].digest[m-1] = 0;
  meta->services._buffer[8].rqstid = CAMERA_StartFilm_RQSTID;
  strncpy(meta->services._buffer[8].name, "StartFilm", l);
  meta->services._buffer[8].name[l-1] = 0;
  strncpy(meta->services._buffer[8].digest, "62357408c1c53751884a1c27b10599", m);
  meta->services._buffer[8].digest[m-1] = 0;
  meta->services._length = 9;

  genom_log_debug("initialized metadata port");
  return 0;
}

genom_event
genom_metadata_camera_fetch(struct genom_component_data *self,
                      const char *comp, pocolibs_metadata_component *meta)
{
  char name[H2_DEV_MAX_NAME];
  POSTER_ID id;
  char *data;
  STATUS s;
  ssize_t m;
  int n;

  n = snprintf(name, sizeof(name), "%s/genom_metadata", comp);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port %s name too long", name);
    genom_log_warn(0, "port name length limited to %d characters",
                   H2_DEV_MAX_NAME);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG },
                        &self->control.context);
  }

  if (posterFind(name, &id) != OK) {
    genom_log_warn(1, "no such port %s", name);
    return genom_no_such_service(&self->control.context);
  }

  s = posterTake(id, POSTER_READ);
  if (s != OK) {
    genom_log_warn(1, "cannot access metadata port %s", name);
    return genom_no_such_service(&self->control.context);
  }

  data = posterAddr(id);
  m = -1;
  s =
    genom_deserialize_t_pocolibs_metadata_component
    (&data, &m, meta);
  if (s) {
    genom_log_warn(1, "cannot read metadata port %s contents", name);
    return genom_no_such_service(&self->control.context);
  }
  posterGive(id);

  return 0;
}



/* --- genom_camera_genom_state_get_ph ---------------------------------- */

static __inline__ struct genom_camera_genom_state_ph *
genom_camera_genom_state_get_ph(
  struct genom_camera_genom_state_port *p)
{
  return &p->h;
}


/* --- genom_camera_genom_state_data ------------------------------------ */

genom_state_component *
genom_camera_genom_state_data(
  genom_context self)
{
  struct genom_camera_genom_state_port *p;
  struct genom_camera_genom_state_ph *ph;

  p = &self->data->self->ports.genom_state;

  ph = genom_camera_genom_state_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_camera_genom_state_open ------------------------------------ */

genom_event
genom_camera_genom_state_open(
  genom_context self)
{
  struct genom_camera_genom_state_port *p;
  struct genom_camera_genom_state_ph *ph;
  char name[H2_DEV_MAX_NAME];
  STATUS s;
  size_t l;
  int n;

  p = &self->data->self->ports.genom_state;

  n = snprintf(name, sizeof(name), "%s/genom_state", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port genom_state name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  l = genom_maxserialen_t_genom_state_component();

  s = posterCreate(name, (int)l, &ph->id);
  if (s == ERROR) {
    genom_log_warn(1, "cannot create outport %s", name);
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);
  }
  ph->size = l;
  genom_log_info("created outport %s", name);
  return genom_ok;
}


/* --- genom_camera_genom_state_close ----------------------------------- */

genom_event
genom_camera_genom_state_close(
  genom_context self)
{
  struct genom_camera_genom_state_port *p;
  struct genom_camera_genom_state_ph *ph;

  p = &self->data->self->ports.genom_state;

  ph = genom_camera_genom_state_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  posterDelete(ph->id);
  genom_log_info("destroyed outport genom_state");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_camera_genom_state_delete ---------------------------------- */

void
genom_camera_genom_state_delete(genom_context self)
{
  genom_camera_genom_state_close(self);
}


/* --- genom_camera_genom_metadata_get_ph ------------------------------- */

static __inline__ struct genom_camera_genom_metadata_ph *
genom_camera_genom_metadata_get_ph(
  struct genom_camera_genom_metadata_port *p)
{
  return &p->h;
}


/* --- genom_camera_genom_metadata_data --------------------------------- */

pocolibs_metadata_component *
genom_camera_genom_metadata_data(
  genom_context self)
{
  struct genom_camera_genom_metadata_port *p;
  struct genom_camera_genom_metadata_ph *ph;

  p = &self->data->self->ports.genom_metadata;

  ph = genom_camera_genom_metadata_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_camera_genom_metadata_open --------------------------------- */

genom_event
genom_camera_genom_metadata_open(
  genom_context self)
{
  struct genom_camera_genom_metadata_port *p;
  struct genom_camera_genom_metadata_ph *ph;
  char name[H2_DEV_MAX_NAME];
  STATUS s;
  size_t l;
  int n;

  p = &self->data->self->ports.genom_metadata;

  n = snprintf(name, sizeof(name), "%s/genom_metadata", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port genom_metadata name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  l = genom_maxserialen_t_pocolibs_metadata_component();

  s = posterCreate(name, (int)l, &ph->id);
  if (s == ERROR) {
    genom_log_warn(1, "cannot create outport %s", name);
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);
  }
  ph->size = l;
  genom_log_info("created outport %s", name);
  return genom_ok;
}


/* --- genom_camera_genom_metadata_close -------------------------------- */

genom_event
genom_camera_genom_metadata_close(
  genom_context self)
{
  struct genom_camera_genom_metadata_port *p;
  struct genom_camera_genom_metadata_ph *ph;

  p = &self->data->self->ports.genom_metadata;

  ph = genom_camera_genom_metadata_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  posterDelete(ph->id);
  genom_log_info("destroyed outport genom_metadata");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_camera_genom_metadata_delete ------------------------------- */

void
genom_camera_genom_metadata_delete(genom_context self)
{
  genom_camera_genom_metadata_close(self);
}


/* --- genom_camera_AR_get_ph ------------------------------------------- */

static __inline__ struct genom_camera_AR_ph *
genom_camera_AR_get_ph(
  struct genom_camera_AR_port *p)
{
  return &p->h;
}


/* --- genom_camera_AR_data --------------------------------------------- */

camera_arena *
genom_camera_AR_data(
  genom_context self)
{
  struct genom_camera_AR_port *p;
  struct genom_camera_AR_ph *ph;

  p = &self->data->self->ports.AR;

  ph = genom_camera_AR_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_camera_AR_open --------------------------------------------- */

genom_event
genom_camera_AR_open(
  genom_context self)
{
  struct genom_camera_AR_port *p;
  struct genom_camera_AR_ph *ph;
  char name[H2_DEV_MAX_NAME];
  STATUS s;
  size_t l;
  int n;

  p = &self->data->self->ports.AR;

  n = snprintf(name, sizeof(name), "%s/AR", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port AR name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  l = genom_maxserialen_t_camera_arena();

  s = posterCreate(name, (int)l, &ph->id);
  if (s == ERROR) {
    genom_log_warn(1, "cannot create outport %s", name);
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);
  }
  ph->size = l;
  genom_log_info("created outport %s", name);
  return genom_ok;
}


/* --- genom_camera_AR_close -------------------------------------------- */

genom_event
genom_camera_AR_close(
  genom_context self)
{
  struct genom_camera_AR_port *p;
  struct genom_camera_AR_ph *ph;

  p = &self->data->self->ports.AR;

  ph = genom_camera_AR_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  posterDelete(ph->id);
  genom_log_info("destroyed outport AR");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_camera_AR_delete ------------------------------------------- */

void
genom_camera_AR_delete(genom_context self)
{
  genom_camera_AR_close(self);
}


/* --- genom_camera_POS_get_ph ------------------------------------------ */

static __inline__ struct genom_camera_POS_ph *
genom_camera_POS_get_ph(
  struct genom_camera_POS_port *p)
{
  return &p->h;
}


/* --- genom_camera_POS_data -------------------------------------------- */

camera_robot *
genom_camera_POS_data(
  genom_context self)
{
  struct genom_camera_POS_port *p;
  struct genom_camera_POS_ph *ph;

  p = &self->data->self->ports.POS;

  ph = genom_camera_POS_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_camera_POS_open -------------------------------------------- */

genom_event
genom_camera_POS_open(
  genom_context self)
{
  struct genom_camera_POS_port *p;
  struct genom_camera_POS_ph *ph;
  char name[H2_DEV_MAX_NAME];
  STATUS s;
  size_t l;
  int n;

  p = &self->data->self->ports.POS;

  n = snprintf(name, sizeof(name), "%s/POS", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port POS name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  l = genom_maxserialen_t_camera_robot();

  s = posterCreate(name, (int)l, &ph->id);
  if (s == ERROR) {
    genom_log_warn(1, "cannot create outport %s", name);
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);
  }
  ph->size = l;
  genom_log_info("created outport %s", name);
  return genom_ok;
}


/* --- genom_camera_POS_close ------------------------------------------- */

genom_event
genom_camera_POS_close(
  genom_context self)
{
  struct genom_camera_POS_port *p;
  struct genom_camera_POS_ph *ph;

  p = &self->data->self->ports.POS;

  ph = genom_camera_POS_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  posterDelete(ph->id);
  genom_log_info("destroyed outport POS");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_camera_POS_delete ------------------------------------------ */

void
genom_camera_POS_delete(genom_context self)
{
  genom_camera_POS_close(self);
}


/* --- genom_camera_IM_get_ph ------------------------------------------- */

static __inline__ struct genom_camera_IM_ph *
genom_camera_IM_get_ph(
  struct genom_camera_IM_port *p)
{
  return &p->h;
}


/* --- genom_camera_IM_data --------------------------------------------- */

camera_map *
genom_camera_IM_data(
  genom_context self)
{
  struct genom_camera_IM_port *p;
  struct genom_camera_IM_ph *ph;

  p = &self->data->self->ports.IM;

  ph = genom_camera_IM_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_camera_IM_open --------------------------------------------- */

genom_event
genom_camera_IM_open(
  genom_context self)
{
  struct genom_camera_IM_port *p;
  struct genom_camera_IM_ph *ph;
  char name[H2_DEV_MAX_NAME];
  STATUS s;
  size_t l;
  int n;

  p = &self->data->self->ports.IM;

  n = snprintf(name, sizeof(name), "%s/IM", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port IM name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  l = genom_maxserialen_t_camera_map();

  s = posterCreate(name, (int)l, &ph->id);
  if (s == ERROR) {
    genom_log_warn(1, "cannot create outport %s", name);
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);
  }
  ph->size = l;
  genom_log_info("created outport %s", name);
  return genom_ok;
}


/* --- genom_camera_IM_close -------------------------------------------- */

genom_event
genom_camera_IM_close(
  genom_context self)
{
  struct genom_camera_IM_port *p;
  struct genom_camera_IM_ph *ph;

  p = &self->data->self->ports.IM;

  ph = genom_camera_IM_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  posterDelete(ph->id);
  genom_log_info("destroyed outport IM");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_camera_IM_delete ------------------------------------------- */

void
genom_camera_IM_delete(genom_context self)
{
  genom_camera_IM_close(self);
}




/* --- genom_camera_genom_state_write ----------------------------------- */

genom_event
genom_camera_genom_state_write(
  genom_context self)
{
  static struct genom_camera_genom_state_port *p;
  struct genom_camera_genom_state_ph *ph;
  STATUS s;
  char *b;
  size_t l;

  p = &self->data->self->ports.genom_state;

  ph = genom_camera_genom_state_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_outport(self);

  l = genom_serialen_t_genom_state_component(
    &(ph->buffer));
  if (l > ph->size || l + (1<<17) < ph->size) {
    s = posterIoctl(ph->id, FIO_RESIZE, &l);
    if (s != OK) {
      genom_log_warn(1, "cannot resize outport genom_state to %zu bytes", l);
      return genom_serialization(self);
    }
    ph->size = l;
  }

  s = posterTake(ph->id, POSTER_WRITE);
  if (s != OK) {
    genom_log_warn(1, "cannot access outport genom_state");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  genom_serialize_t_genom_state_component(
    &b, &(ph->buffer));
  s = posterGive(ph->id);
  if (s != OK) {
    genom_log_warn(1, "cannot flush outport genom_state");
    return genom_port_io(self);
  }

  return genom_ok;
}


/* --- genom_camera_genom_metadata_write -------------------------------- */

genom_event
genom_camera_genom_metadata_write(
  genom_context self)
{
  static struct genom_camera_genom_metadata_port *p;
  struct genom_camera_genom_metadata_ph *ph;
  STATUS s;
  char *b;
  size_t l;

  p = &self->data->self->ports.genom_metadata;

  ph = genom_camera_genom_metadata_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_outport(self);

  l = genom_serialen_t_pocolibs_metadata_component(
    &(ph->buffer));
  if (l > ph->size || l + (1<<17) < ph->size) {
    s = posterIoctl(ph->id, FIO_RESIZE, &l);
    if (s != OK) {
      genom_log_warn(1, "cannot resize outport genom_metadata to %zu bytes", l);
      return genom_serialization(self);
    }
    ph->size = l;
  }

  s = posterTake(ph->id, POSTER_WRITE);
  if (s != OK) {
    genom_log_warn(1, "cannot access outport genom_metadata");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  genom_serialize_t_pocolibs_metadata_component(
    &b, &(ph->buffer));
  s = posterGive(ph->id);
  if (s != OK) {
    genom_log_warn(1, "cannot flush outport genom_metadata");
    return genom_port_io(self);
  }

  return genom_ok;
}


/* --- genom_camera_AR_write -------------------------------------------- */

genom_event
genom_camera_AR_write(
  genom_context self)
{
  static struct genom_camera_AR_port *p;
  struct genom_camera_AR_ph *ph;
  STATUS s;
  char *b;
  size_t l;

  p = &self->data->self->ports.AR;

  ph = genom_camera_AR_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_outport(self);

  l = genom_serialen_t_camera_arena(
    &(ph->buffer));
  if (l > ph->size || l + (1<<17) < ph->size) {
    s = posterIoctl(ph->id, FIO_RESIZE, &l);
    if (s != OK) {
      genom_log_warn(1, "cannot resize outport AR to %zu bytes", l);
      return genom_serialization(self);
    }
    ph->size = l;
  }

  s = posterTake(ph->id, POSTER_WRITE);
  if (s != OK) {
    genom_log_warn(1, "cannot access outport AR");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  genom_serialize_t_camera_arena(
    &b, &(ph->buffer));
  s = posterGive(ph->id);
  if (s != OK) {
    genom_log_warn(1, "cannot flush outport AR");
    return genom_port_io(self);
  }

  return genom_ok;
}


/* --- genom_camera_POS_write ------------------------------------------- */

genom_event
genom_camera_POS_write(
  genom_context self)
{
  static struct genom_camera_POS_port *p;
  struct genom_camera_POS_ph *ph;
  STATUS s;
  char *b;
  size_t l;

  p = &self->data->self->ports.POS;

  ph = genom_camera_POS_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_outport(self);

  l = genom_serialen_t_camera_robot(
    &(ph->buffer));
  if (l > ph->size || l + (1<<17) < ph->size) {
    s = posterIoctl(ph->id, FIO_RESIZE, &l);
    if (s != OK) {
      genom_log_warn(1, "cannot resize outport POS to %zu bytes", l);
      return genom_serialization(self);
    }
    ph->size = l;
  }

  s = posterTake(ph->id, POSTER_WRITE);
  if (s != OK) {
    genom_log_warn(1, "cannot access outport POS");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  genom_serialize_t_camera_robot(
    &b, &(ph->buffer));
  s = posterGive(ph->id);
  if (s != OK) {
    genom_log_warn(1, "cannot flush outport POS");
    return genom_port_io(self);
  }

  return genom_ok;
}


/* --- genom_camera_IM_write -------------------------------------------- */

genom_event
genom_camera_IM_write(
  genom_context self)
{
  static struct genom_camera_IM_port *p;
  struct genom_camera_IM_ph *ph;
  STATUS s;
  char *b;
  size_t l;

  p = &self->data->self->ports.IM;

  ph = genom_camera_IM_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_outport(self);

  l = genom_serialen_t_camera_map(
    &(ph->buffer));
  if (l > ph->size || l + (1<<17) < ph->size) {
    s = posterIoctl(ph->id, FIO_RESIZE, &l);
    if (s != OK) {
      genom_log_warn(1, "cannot resize outport IM to %zu bytes", l);
      return genom_serialization(self);
    }
    ph->size = l;
  }

  s = posterTake(ph->id, POSTER_WRITE);
  if (s != OK) {
    genom_log_warn(1, "cannot access outport IM");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  genom_serialize_t_camera_map(
    &b, &(ph->buffer));
  s = posterGive(ph->id);
  if (s != OK) {
    genom_log_warn(1, "cannot flush outport IM");
    return genom_port_io(self);
  }

  return genom_ok;
}


/* --- end of file --------------------------------------------------------- */

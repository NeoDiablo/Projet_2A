/* --- Generated by genom 2.99.29. Do not edit -------------------------- */

#include "autoconf/acheader.h"

#include "display_control_task.h"
#include "display_activity.h"


/* --- genom_display_activity_alloc ------------------------------------- */

int
genom_display_activity_alloc(struct genom_activities *activities)
{
  static int aid = 0;
  size_t id;

  /* look for the first free activity */
  for(id = 0; id < genom_max_activities(); id++) {
    if (activities->a[id].any.status == ACT_VOID) {
      activities->a[id].any.aid = ++aid;
      activities->a[id].any.status = ACT_INIT;
      activities->a[id].any.start = 0;
      activities->a[id].any.stop = 0;
      activities->a[id].any.pause = 0;
      return id;
    }
  }

  return -1;
}


/* === Send final replies ================================================== */

/* abort_activity */
static __inline__ void
genom_display_abort_activity_activity_report(
  struct genom_component_data *self,
  struct genom_display_abort_activity_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == display_ether) {
    /* success: update after/before array */
    self->control.run_map[DISPLAY_abort_activity_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_display_abort_activity_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_display_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "abort_activity");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_display_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "abort_activity");
    } else
      genom_log_warn(0, "invalid output for service %s", "abort_activity");
  }

  /* cleanup */
  genom_tfini_display_abort_activity_activity(a);
}

/* connect_port */
static __inline__ void
genom_display_connect_port_activity_report(
  struct genom_component_data *self,
  struct genom_display_connect_port_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == display_ether) {
    /* success: update after/before array */
    self->control.run_map[DISPLAY_connect_port_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_display_connect_port_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_display_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "connect_port");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_display_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "connect_port");
    } else
      genom_log_warn(0, "invalid output for service %s", "connect_port");
  }

  /* cleanup */
  genom_tfini_display_connect_port_activity(a);
}

/* connect_service */
static __inline__ void
genom_display_connect_service_activity_report(
  struct genom_component_data *self,
  struct genom_display_connect_service_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == display_ether) {
    /* success: update after/before array */
    self->control.run_map[DISPLAY_connect_service_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_display_connect_service_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_display_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "connect_service");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_display_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "connect_service");
    } else
      genom_log_warn(0, "invalid output for service %s", "connect_service");
  }

  /* cleanup */
  genom_tfini_display_connect_service_activity(a);
}

/* kill */
static __inline__ void
genom_display_kill_activity_report(
  struct genom_component_data *self,
  struct genom_display_kill_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == display_ether) {
    /* success: update after/before array */
    self->control.run_map[DISPLAY_kill_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_display_kill_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_display_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "kill");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_display_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "kill");
    } else
      genom_log_warn(0, "invalid output for service %s", "kill");
  }

  /* cleanup */
  genom_tfini_display_kill_activity(a);
}

/* GetCurrentPosition */
static __inline__ void
genom_display_GetCurrentPosition_activity_report(
  struct genom_component_data *self,
  struct genom_display_GetCurrentPosition_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == display_ether) {
    /* success: update after/before array */
    self->control.run_map[DISPLAY_GetCurrentPosition_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_display_GetCurrentPosition_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_display_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "GetCurrentPosition");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_display_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "GetCurrentPosition");
    } else
      genom_log_warn(0, "invalid output for service %s", "GetCurrentPosition");
  }

  /* cleanup */
  genom_tfini_display_GetCurrentPosition_activity(a);
}

/* GetCurrentBattery */
static __inline__ void
genom_display_GetCurrentBattery_activity_report(
  struct genom_component_data *self,
  struct genom_display_GetCurrentBattery_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == display_ether) {
    /* success: update after/before array */
    self->control.run_map[DISPLAY_GetCurrentBattery_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_display_GetCurrentBattery_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_display_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "GetCurrentBattery");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_display_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "GetCurrentBattery");
    } else
      genom_log_warn(0, "invalid output for service %s", "GetCurrentBattery");
  }

  /* cleanup */
  genom_tfini_display_GetCurrentBattery_activity(a);
}

/* GetCurrentMap */
static __inline__ void
genom_display_GetCurrentMap_activity_report(
  struct genom_component_data *self,
  struct genom_display_GetCurrentMap_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == display_ether) {
    /* success: update after/before array */
    self->control.run_map[DISPLAY_GetCurrentMap_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_display_GetCurrentMap_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_display_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "GetCurrentMap");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_display_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "GetCurrentMap");
    } else
      genom_log_warn(0, "invalid output for service %s", "GetCurrentMap");
  }

  /* cleanup */
  genom_tfini_display_GetCurrentMap_activity(a);
}

/* GetCurrentArena */
static __inline__ void
genom_display_GetCurrentArena_activity_report(
  struct genom_component_data *self,
  struct genom_display_GetCurrentArena_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == display_ether) {
    /* success: update after/before array */
    self->control.run_map[DISPLAY_GetCurrentArena_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_display_GetCurrentArena_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_display_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "GetCurrentArena");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_display_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "GetCurrentArena");
    } else
      genom_log_warn(0, "invalid output for service %s", "GetCurrentArena");
  }

  /* cleanup */
  genom_tfini_display_GetCurrentArena_activity(a);
}

/* SendOrdersStop */
static __inline__ void
genom_display_SendOrdersStop_activity_report(
  struct genom_component_data *self,
  struct genom_display_SendOrdersStop_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == display_ether) {
    /* success: update after/before array */
    self->control.run_map[DISPLAY_SendOrdersStop_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_display_SendOrdersStop_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_display_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "SendOrdersStop");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_display_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "SendOrdersStop");
    } else
      genom_log_warn(0, "invalid output for service %s", "SendOrdersStop");
  }

  /* cleanup */
  genom_tfini_display_SendOrdersStop_activity(a);
}

/* MonitoringStop */
static __inline__ void
genom_display_MonitoringStop_activity_report(
  struct genom_component_data *self,
  struct genom_display_MonitoringStop_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == display_ether) {
    /* success: update after/before array */
    self->control.run_map[DISPLAY_MonitoringStop_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_display_MonitoringStop_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_display_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "MonitoringStop");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_display_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "MonitoringStop");
    } else
      genom_log_warn(0, "invalid output for service %s", "MonitoringStop");
  }

  /* cleanup */
  genom_tfini_display_MonitoringStop_activity(a);
}

/* SendOrders */
static __inline__ void
genom_display_SendOrders_activity_report(
  struct genom_component_data *self,
  struct genom_display_SendOrders_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == display_ether) {
    /* success: update after/before array */
    self->control.run_map[DISPLAY_SendOrders_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_display_SendOrders_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_display_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "SendOrders");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_display_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "SendOrders");
    } else
      genom_log_warn(0, "invalid output for service %s", "SendOrders");
  }

  /* cleanup */
  genom_tfini_display_SendOrders_activity(a);
}

/* Monitoring */
static __inline__ void
genom_display_Monitoring_activity_report(
  struct genom_component_data *self,
  struct genom_display_Monitoring_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == display_ether) {
    /* success: update after/before array */
    self->control.run_map[DISPLAY_Monitoring_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_display_Monitoring_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_display_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "Monitoring");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_display_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "Monitoring");
    } else
      genom_log_warn(0, "invalid output for service %s", "Monitoring");
  }

  /* cleanup */
  genom_tfini_display_Monitoring_activity(a);
}


/* --- genom_display_activity_report ------------------------------------ */

void
genom_display_activity_report(
  struct genom_component_data *self, struct genom_activity *a)
{
  switch(a->sid) {
    case -1: return; /* permanent activity reports nothing */

    case DISPLAY_abort_activity_RQSTID:
      genom_display_abort_activity_activity_report(
        self, (struct genom_display_abort_activity_activity *)a);
      return;
    case DISPLAY_connect_port_RQSTID:
      genom_display_connect_port_activity_report(
        self, (struct genom_display_connect_port_activity *)a);
      return;
    case DISPLAY_connect_service_RQSTID:
      genom_display_connect_service_activity_report(
        self, (struct genom_display_connect_service_activity *)a);
      return;
    case DISPLAY_kill_RQSTID:
      genom_display_kill_activity_report(
        self, (struct genom_display_kill_activity *)a);
      return;
    case DISPLAY_GetCurrentPosition_RQSTID:
      genom_display_GetCurrentPosition_activity_report(
        self, (struct genom_display_GetCurrentPosition_activity *)a);
      return;
    case DISPLAY_GetCurrentBattery_RQSTID:
      genom_display_GetCurrentBattery_activity_report(
        self, (struct genom_display_GetCurrentBattery_activity *)a);
      return;
    case DISPLAY_GetCurrentMap_RQSTID:
      genom_display_GetCurrentMap_activity_report(
        self, (struct genom_display_GetCurrentMap_activity *)a);
      return;
    case DISPLAY_GetCurrentArena_RQSTID:
      genom_display_GetCurrentArena_activity_report(
        self, (struct genom_display_GetCurrentArena_activity *)a);
      return;
    case DISPLAY_SendOrdersStop_RQSTID:
      genom_display_SendOrdersStop_activity_report(
        self, (struct genom_display_SendOrdersStop_activity *)a);
      return;
    case DISPLAY_MonitoringStop_RQSTID:
      genom_display_MonitoringStop_activity_report(
        self, (struct genom_display_MonitoringStop_activity *)a);
      return;
    case DISPLAY_SendOrders_RQSTID:
      genom_display_SendOrders_activity_report(
        self, (struct genom_display_SendOrders_activity *)a);
      return;
    case DISPLAY_Monitoring_RQSTID:
      genom_display_Monitoring_activity_report(
        self, (struct genom_display_Monitoring_activity *)a);
      return;
  }

  assert(!"code not reached");
}


/* --- genom_display_activity_encodex ------------------------------------ */

int
genom_display_activity_encodex(char *buffer, int size, char *dst, int maxsize)
{
  struct genom_activity *a = (struct genom_activity *)buffer;

  if (a->state == genom_unkex_id)
    return genom_display_genom_unkex_encodex(a->exdetail, size, dst, maxsize);
  else if (a->state == genom_syserr_id)
    return genom_display_genom_syserr_encodex(a->exdetail, size, dst, maxsize);
  else if (a->state == genom_incompatible_digest_id)
    return genom_display_genom_incompatible_digest_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_bad_transition_id)
    return genom_display_genom_bad_transition_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_interrupted_id)
    return genom_display_genom_interrupted_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_serialization_id)
    return genom_display_genom_serialization_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_too_many_activities_id)
    return genom_display_genom_too_many_activities_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_disallowed_id)
    return genom_display_genom_disallowed_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_mwerr_id)
    return genom_display_genom_mwerr_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_no_such_activity_id)
    return genom_display_genom_no_such_activity_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_no_such_inport_id)
    return genom_display_genom_no_such_inport_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_no_such_outport_id)
    return genom_display_genom_no_such_outport_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_port_io_id)
    return genom_display_genom_port_io_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_no_such_remote_id)
    return genom_display_genom_no_such_remote_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_no_such_service_id)
    return genom_display_genom_no_such_service_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_remote_io_id)
    return genom_display_genom_remote_io_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == display_INVALID_ORDER_id)
    return genom_display_display_INVALID_ORDER_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == display_INVALID_DATA_id)
    return genom_display_display_INVALID_DATA_encodex(
      a->exdetail, size, dst, maxsize);

  assert(!"unknown genom exception");
  return 0;
}


/* === Interrupt incompatible activities =================================== */

/* abort_activity */
static __inline__ int
genom_display_abort_activity_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}

/* connect_port */
static __inline__ int
genom_display_connect_port_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}

/* connect_service */
static __inline__ int
genom_display_connect_service_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}

/* kill */
static __inline__ int
genom_display_kill_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  /* task orders */
  pthread_mutex_lock(&self->tasks.orders.lock);
  {
    struct genom_activity *c;
    size_t id;

    for(id = 0; id < genom_max_activities(); id++) {
      c = &self->tasks.orders.activities.a[id].any;
      if (c->status == ACT_VOID || c->status == ACT_ETHER) continue;
      if (c->aid == a->aid) continue;
      switch(c->sid) {
        case DISPLAY_SendOrders_RQSTID:
          switch(c->status) {
            case ACT_RUN:
              delay = 1;
              if (!self->tasks.orders.runnable) {
                self->tasks.orders.runnable = 1;
                pthread_cond_broadcast(&self->tasks.orders.sync);
              }
              /*FALLTHROUGH*/
            case ACT_INIT:
              c->stop = 1;
              c->interruptedby = "kill";
              break;

            case ACT_STOP: delay = 1; break;

            default: assert(!"code not reached");
          }
      }
    }
  }
  pthread_mutex_unlock(&self->tasks.orders.lock);

  /* task monitor */
  pthread_mutex_lock(&self->tasks.monitor.lock);
  {
    struct genom_activity *c;
    size_t id;

    for(id = 0; id < genom_max_activities(); id++) {
      c = &self->tasks.monitor.activities.a[id].any;
      if (c->status == ACT_VOID || c->status == ACT_ETHER) continue;
      if (c->aid == a->aid) continue;
      switch(c->sid) {
        case DISPLAY_Monitoring_RQSTID:
          switch(c->status) {
            case ACT_RUN:
              delay = 1;
              if (!self->tasks.monitor.runnable) {
                self->tasks.monitor.runnable = 1;
                pthread_cond_broadcast(&self->tasks.monitor.sync);
              }
              /*FALLTHROUGH*/
            case ACT_INIT:
              c->stop = 1;
              c->interruptedby = "kill";
              break;

            case ACT_STOP: delay = 1; break;

            default: assert(!"code not reached");
          }
      }
    }
  }
  pthread_mutex_unlock(&self->tasks.monitor.lock);

  return delay;
}

/* GetCurrentPosition */
static __inline__ int
genom_display_GetCurrentPosition_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}

/* GetCurrentBattery */
static __inline__ int
genom_display_GetCurrentBattery_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}

/* GetCurrentMap */
static __inline__ int
genom_display_GetCurrentMap_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}

/* GetCurrentArena */
static __inline__ int
genom_display_GetCurrentArena_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}

/* SendOrdersStop */
static __inline__ int
genom_display_SendOrdersStop_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  /* task orders */
  pthread_mutex_lock(&self->tasks.orders.lock);
  {
    struct genom_activity *c;
    size_t id;

    for(id = 0; id < genom_max_activities(); id++) {
      c = &self->tasks.orders.activities.a[id].any;
      if (c->status == ACT_VOID || c->status == ACT_ETHER) continue;
      if (c->aid == a->aid) continue;
      switch(c->sid) {
        case DISPLAY_SendOrders_RQSTID:
          switch(c->status) {
            case ACT_RUN:
              delay = 1;
              if (!self->tasks.orders.runnable) {
                self->tasks.orders.runnable = 1;
                pthread_cond_broadcast(&self->tasks.orders.sync);
              }
              /*FALLTHROUGH*/
            case ACT_INIT:
              c->stop = 1;
              c->interruptedby = "SendOrdersStop";
              break;

            case ACT_STOP: delay = 1; break;

            default: assert(!"code not reached");
          }
      }
    }
  }
  pthread_mutex_unlock(&self->tasks.orders.lock);

  return delay;
}

/* MonitoringStop */
static __inline__ int
genom_display_MonitoringStop_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  /* task monitor */
  pthread_mutex_lock(&self->tasks.monitor.lock);
  {
    struct genom_activity *c;
    size_t id;

    for(id = 0; id < genom_max_activities(); id++) {
      c = &self->tasks.monitor.activities.a[id].any;
      if (c->status == ACT_VOID || c->status == ACT_ETHER) continue;
      if (c->aid == a->aid) continue;
      switch(c->sid) {
        case DISPLAY_Monitoring_RQSTID:
          switch(c->status) {
            case ACT_RUN:
              delay = 1;
              if (!self->tasks.monitor.runnable) {
                self->tasks.monitor.runnable = 1;
                pthread_cond_broadcast(&self->tasks.monitor.sync);
              }
              /*FALLTHROUGH*/
            case ACT_INIT:
              c->stop = 1;
              c->interruptedby = "MonitoringStop";
              break;

            case ACT_STOP: delay = 1; break;

            default: assert(!"code not reached");
          }
      }
    }
  }
  pthread_mutex_unlock(&self->tasks.monitor.lock);

  return delay;
}

/* SendOrders */
static __inline__ int
genom_display_SendOrders_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}

/* Monitoring */
static __inline__ int
genom_display_Monitoring_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}


/* --- genom_display_interrupt_reqd ------------------------------------- */

int
genom_display_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  /* interrupt incompatible activities */
  switch(a->sid) {
    case -1: return 0; /* permanent activity is not interruptible */

    case DISPLAY_abort_activity_RQSTID:
      return genom_display_abort_activity_interrupt_reqd(self, a);
    case DISPLAY_connect_port_RQSTID:
      return genom_display_connect_port_interrupt_reqd(self, a);
    case DISPLAY_connect_service_RQSTID:
      return genom_display_connect_service_interrupt_reqd(self, a);
    case DISPLAY_kill_RQSTID:
      return genom_display_kill_interrupt_reqd(self, a);
    case DISPLAY_GetCurrentPosition_RQSTID:
      return genom_display_GetCurrentPosition_interrupt_reqd(self, a);
    case DISPLAY_GetCurrentBattery_RQSTID:
      return genom_display_GetCurrentBattery_interrupt_reqd(self, a);
    case DISPLAY_GetCurrentMap_RQSTID:
      return genom_display_GetCurrentMap_interrupt_reqd(self, a);
    case DISPLAY_GetCurrentArena_RQSTID:
      return genom_display_GetCurrentArena_interrupt_reqd(self, a);
    case DISPLAY_SendOrdersStop_RQSTID:
      return genom_display_SendOrdersStop_interrupt_reqd(self, a);
    case DISPLAY_MonitoringStop_RQSTID:
      return genom_display_MonitoringStop_interrupt_reqd(self, a);
    case DISPLAY_SendOrders_RQSTID:
      return genom_display_SendOrders_interrupt_reqd(self, a);
    case DISPLAY_Monitoring_RQSTID:
      return genom_display_Monitoring_interrupt_reqd(self, a);
  }

  assert(!"code not reached");
  return 0;
}

/* --- Generated by genom 2.99.29. Do not edit -------------------------- */

#include "autoconf/acheader.h"

#include <sys/types.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#include "commonStructLib.h"
#include "h2evnLib.h"
#include "taskLib.h"

#include "display_parameters.h"
#include "display_msglib.h"
#include "display_activity.h"
#include "display_control_task.h"
#include "typecopy.h"


/* --- local data ---------------------------------------------------------- */

#define CNTRL_TASK_MIN_STACK_SIZE 4096
#define EXEC_TASK_MIN_STACK_SIZE  4096

/* cslib server with context pointer, for reentrant csLib callbacks */
struct CS_SERV_IDS {
  CS_SERV csserv;
  struct genom_component_data *self;
};

static void	display_abort_activity_rqstcb(SERV_ID csserv, int sid);
static void	display_connect_port_rqstcb(SERV_ID csserv, int sid);
static void	display_connect_service_rqstcb(SERV_ID csserv, int sid);
static void	display_kill_rqstcb(SERV_ID csserv, int sid);
static void	display_GetCurrentPosition_rqstcb(SERV_ID csserv, int sid);
static void	display_GetCurrentBattery_rqstcb(SERV_ID csserv, int sid);
static void	display_GetCurrentMap_rqstcb(SERV_ID csserv, int sid);
static void	display_GetCurrentArena_rqstcb(SERV_ID csserv, int sid);
static void	display_SendOrdersStop_rqstcb(SERV_ID csserv, int sid);
static void	display_MonitoringStop_rqstcb(SERV_ID csserv, int sid);
static void	display_SendOrders_rqstcb(SERV_ID csserv, int sid);
static void	display_Monitoring_rqstcb(SERV_ID csserv, int sid);
static void *	display_cntrl_task(void *);


/* --- genom_display_init ----------------------------------------------- */

void *
genom_display_init(void)
{
  struct genom_component_data *self;
  char tname[64];

  /* create internal data structure */
  self = malloc(sizeof(*self));
  if (!self) {
    genom_log_warn(1, "cannot create internal data structure");
    return NULL;
  }

  genom_tinit_t_display_ids(&self->ids);
  genom_tinit_display_genom_state_port(&self->ports.genom_state);
  genom_tinit_display_genom_metadata_port(&self->ports.genom_metadata);
  genom_tinit_display_JS_port(&self->ports.JS);
  genom_tinit_display_IM_port(&self->ports.IM);
  genom_tinit_display_AR_port(&self->ports.AR);
  genom_tinit_display_POS_port(&self->ports.POS);
  genom_tinit_display_BAT_port(&self->ports.BAT);

  self->tasks.orders.context.raise = genom_pocolibs_raise;
  self->tasks.orders.context.raised = genom_pocolibs_raised;
  self->tasks.orders.context.data =
    &self->tasks.orders.context_data;

  self->tasks.orders.context_data.self = self;
  self->tasks.orders.context_data.ex = genom_ok;
  self->tasks.orders.context_data.exdetail = NULL;
  self->tasks.orders.context_data.exsize = 0;

  self->tasks.orders.taskid = ERROR;

  self->tasks.orders.rusage.cycles = 0;
  self->tasks.orders.rusage.timings.last = 0.;
  self->tasks.orders.rusage.timings.max = 0.;
  self->tasks.orders.rusage.timings.avg = 0.;
  self->tasks.orders.rusage.load.last = 0.;
  self->tasks.orders.rusage.load.max = 0.;
  self->tasks.orders.rusage.load.avg = 0.;
  pthread_spin_init(&self->tasks.orders.rlock, 0);

  self->tasks.orders.runnable = 1;
  self->tasks.orders.shutdown = 0;
  {
    size_t i;
    for(i = 0; i < genom_max_activities(); i++)
      self->tasks.orders.activities.a[i].any.status = ACT_VOID;
    i = genom_display_activity_alloc(&self->tasks.orders.activities);
    assert(i == 0);
    self->tasks.orders.permanent =
      &self->tasks.orders.activities.a[i].any;
  }
  self->tasks.orders.permanent->sid = -1;
  self->tasks.orders.permanent->rid = -1;
  self->tasks.orders.permanent->status = ACT_INIT;
  self->tasks.orders.permanent->start = 1;

  pthread_mutex_init(&self->tasks.orders.lock, NULL);
  pthread_cond_init(&self->tasks.orders.sync, NULL);

  self->tasks.monitor.context.raise = genom_pocolibs_raise;
  self->tasks.monitor.context.raised = genom_pocolibs_raised;
  self->tasks.monitor.context.data =
    &self->tasks.monitor.context_data;

  self->tasks.monitor.context_data.self = self;
  self->tasks.monitor.context_data.ex = genom_ok;
  self->tasks.monitor.context_data.exdetail = NULL;
  self->tasks.monitor.context_data.exsize = 0;

  self->tasks.monitor.taskid = ERROR;

  self->tasks.monitor.rusage.cycles = 0;
  self->tasks.monitor.rusage.timings.last = 0.;
  self->tasks.monitor.rusage.timings.max = 0.;
  self->tasks.monitor.rusage.timings.avg = 0.;
  self->tasks.monitor.rusage.load.last = 0.;
  self->tasks.monitor.rusage.load.max = 0.;
  self->tasks.monitor.rusage.load.avg = 0.;
  pthread_spin_init(&self->tasks.monitor.rlock, 0);

  self->tasks.monitor.runnable = 1;
  self->tasks.monitor.shutdown = 0;
  {
    size_t i;
    for(i = 0; i < genom_max_activities(); i++)
      self->tasks.monitor.activities.a[i].any.status = ACT_VOID;
    i = genom_display_activity_alloc(&self->tasks.monitor.activities);
    assert(i == 0);
    self->tasks.monitor.permanent =
      &self->tasks.monitor.activities.a[i].any;
  }
  self->tasks.monitor.permanent->sid = -1;
  self->tasks.monitor.permanent->rid = -1;
  self->tasks.monitor.permanent->status = ACT_INIT;
  self->tasks.monitor.permanent->start = 1;

  pthread_mutex_init(&self->tasks.monitor.lock, NULL);
  pthread_cond_init(&self->tasks.monitor.sync, NULL);

  self->control.context.raise = genom_pocolibs_raise;
  self->control.context.raised = genom_pocolibs_raised;

  self->control.context.data = &self->control.context_data;
  self->control.context_data.self = self;
  self->control.context_data.ex = genom_ok;
  self->control.context_data.exdetail = NULL;
  self->control.context_data.exsize = 0;

  self->control.taskid = ERROR;
  snprintf(self->control.mbox_name, sizeof(self->control.mbox_name),
           "%s", genom_instance);
  self->control.csserv = NULL;
  self->control.shutdown = 0;
  self->control.activity.any.status = ACT_VOID;
  memset(self->control.run_map, 0, sizeof(self->control.run_map));
  pthread_spin_init(&self->control.rlock, 0);
  pthread_mutex_init(&self->control.lock, NULL);
  pthread_cond_init(&self->control.sync, NULL);

  self->resources.all = 0;
  self->resources.control = NULL;
  self->resources.task_orders = NULL;
  self->resources.task_monitor = NULL;
  self->resources.q = 0;
  self->resources.qnext = 0;
  pthread_mutex_init(&self->resources.lock, NULL);
  pthread_cond_init(&self->resources.sync, NULL);

  /* create posters */
  if (genom_metadata_display_init(self)) goto error;
  if (genom_state_display_init(self)) goto error;
  if (genom_display_genom_state_open(&self->control.context)) goto error;
  if (genom_display_genom_metadata_open(&self->control.context)) goto error;
  if (genom_display_JS_open(&self->control.context)) goto error;
  if (genom_display_IM_open(&self->control.context)) goto error;
  if (genom_display_AR_open(&self->control.context)) goto error;
  if (genom_display_POS_open(&self->control.context)) goto error;
  if (genom_display_BAT_open(&self->control.context)) goto error;
  if (genom_display_genom_metadata_write(&self->control.context)) goto error;
  if (genom_display_genom_state_write(&self->control.context)) goto error;

  /* spawn orders task */
  snprintf(tname, sizeof(tname), "%s/%s", genom_instance, "orders");
  pthread_mutex_lock(&self->tasks.orders.lock);
  self->tasks.orders.taskid =
    taskSpawn2(tname, 255,
               VX_FP_TASK, EXEC_TASK_MIN_STACK_SIZE + 8388608,
               genom_display_orders_exec_task, self);
  while (self->tasks.orders.taskid != ERROR &&
         self->tasks.orders.permanent->start)
    pthread_cond_wait(&self->tasks.orders.sync,
                      &self->tasks.orders.lock);

  genom_state_display_update(self, &self->tasks.orders.activities,
    display_orders_TASKID);
  if (self->tasks.orders.taskid == ERROR) {
    genom_log_warn(1, "cannot spawn %s exec task", "orders");
    pthread_mutex_unlock(&self->tasks.orders.lock);
    goto error;
  }
  if (self->tasks.orders.permanent->status == ACT_ETHER &&
      self->tasks.orders.permanent->state != display_ether) {
    genom_log_warn(0, "%s exec task failed", "orders");
    pthread_mutex_unlock(&self->tasks.orders.lock);
    goto error;
  }
  pthread_mutex_unlock(&self->tasks.orders.lock);
  genom_state_display_refresh(self);

  /* spawn monitor task */
  snprintf(tname, sizeof(tname), "%s/%s", genom_instance, "monitor");
  pthread_mutex_lock(&self->tasks.monitor.lock);
  self->tasks.monitor.taskid =
    taskSpawn2(tname, 255,
               VX_FP_TASK, EXEC_TASK_MIN_STACK_SIZE + 8388608,
               genom_display_monitor_exec_task, self);
  while (self->tasks.monitor.taskid != ERROR &&
         self->tasks.monitor.permanent->start)
    pthread_cond_wait(&self->tasks.monitor.sync,
                      &self->tasks.monitor.lock);

  genom_state_display_update(self, &self->tasks.monitor.activities,
    display_monitor_TASKID);
  if (self->tasks.monitor.taskid == ERROR) {
    genom_log_warn(1, "cannot spawn %s exec task", "monitor");
    pthread_mutex_unlock(&self->tasks.monitor.lock);
    goto error;
  }
  if (self->tasks.monitor.permanent->status == ACT_ETHER &&
      self->tasks.monitor.permanent->state != display_ether) {
    genom_log_warn(0, "%s exec task failed", "monitor");
    pthread_mutex_unlock(&self->tasks.monitor.lock);
    goto error;
  }
  pthread_mutex_unlock(&self->tasks.monitor.lock);
  genom_state_display_refresh(self);


  /* spawn control task */
  snprintf(tname, sizeof(tname), "%s", genom_instance);
  pthread_mutex_lock(&self->control.lock);
  if (taskSpawn2(tname, 10 /* priority */,
                 VX_FP_TASK, DISPLAY_MAX_RQST_SIZE + DISPLAY_MAX_REPLY_SIZE
                 + CNTRL_TASK_MIN_STACK_SIZE /*size*/,
                 display_cntrl_task, self) == ERROR) {
    genom_log_warn(1, "cannot spawn control task");
    pthread_mutex_unlock(&self->control.lock);
    goto error;
  }
  while (self->control.taskid == ERROR)
    pthread_cond_wait(&self->control.sync, &self->control.lock);
  if (self->control.taskid == 0) {
    self->control.taskid = ERROR;
    pthread_mutex_unlock(&self->control.lock);
    goto error;
  }
  pthread_mutex_unlock(&self->control.lock);

  genom_log_info("setup and running");
  return self;

error:
  genom_display_fini(self);
  return NULL;
}


/* --- genom_display_fini ----------------------------------------------- */

void
genom_display_fini(void *data)
{
  struct genom_component_data *self = data;

  /* interrupt & wait for all regular activities */
  if (self->tasks.orders.taskid != ERROR) {
    struct genom_activity *a;
    int delay;
    size_t id;

    genom_log_debug("interrupting task orders activities");
    pthread_mutex_lock(&self->tasks.orders.lock);
    do {
      delay = 0;
      for(id = 0; id < genom_max_activities(); id++) {
        a = &self->tasks.orders.activities.a[id].any;
        if (a == self->tasks.orders.permanent) continue;

        if (a->status == ACT_INIT || a->status == ACT_RUN) {
          if (!a->stop) {
            a->stop = 1;
            a->interruptedby = "kill";
            if (!self->tasks.orders.runnable) {
              self->tasks.orders.runnable = 1;
              pthread_cond_broadcast(&self->tasks.orders.sync);
            }
          }
          delay = 1;
        } else if (a->status == ACT_STOP)
          delay = 1;
      }
      if (delay)
        pthread_cond_wait(&self->tasks.orders.sync,
                          &self->tasks.orders.lock);
    } while(delay);
    pthread_mutex_unlock(&self->tasks.orders.lock);
  }

  if (self->tasks.monitor.taskid != ERROR) {
    struct genom_activity *a;
    int delay;
    size_t id;

    genom_log_debug("interrupting task monitor activities");
    pthread_mutex_lock(&self->tasks.monitor.lock);
    do {
      delay = 0;
      for(id = 0; id < genom_max_activities(); id++) {
        a = &self->tasks.monitor.activities.a[id].any;
        if (a == self->tasks.monitor.permanent) continue;

        if (a->status == ACT_INIT || a->status == ACT_RUN) {
          if (!a->stop) {
            a->stop = 1;
            a->interruptedby = "kill";
            if (!self->tasks.monitor.runnable) {
              self->tasks.monitor.runnable = 1;
              pthread_cond_broadcast(&self->tasks.monitor.sync);
            }
          }
          delay = 1;
        } else if (a->status == ACT_STOP)
          delay = 1;
      }
      if (delay)
        pthread_cond_wait(&self->tasks.monitor.sync,
                          &self->tasks.monitor.lock);
    } while(delay);
    pthread_mutex_unlock(&self->tasks.monitor.lock);
  }

  /* interrupt permanent activities */
  if (self->tasks.monitor.taskid != ERROR) {
    struct genom_activity *a;

    genom_log_debug("interrupting task monitor");
    pthread_mutex_lock(&self->tasks.monitor.lock);

    a = self->tasks.monitor.permanent;
    if (!a) {
      /* activity was ether, realloc one */
      int i = genom_display_activity_alloc(
        &self->tasks.monitor.activities);
      assert(i>=0);
      a = &self->tasks.monitor.activities.a[i].any;
      a->sid = a->rid = -1;
    }
    if (a->status != ACT_STOP) {
      if (a->status == ACT_ETHER) a->status = ACT_INIT;
      a->stop = 1;
      a->interruptedby = "kill";
      self->tasks.monitor.permanent = a;
      self->tasks.monitor.runnable = 1;
      pthread_cond_broadcast(&self->tasks.monitor.sync);
    }
    while(self->tasks.monitor.permanent &&
          self->tasks.monitor.permanent->status != ACT_ETHER)
      pthread_cond_wait(&self->tasks.monitor.sync,
                        &self->tasks.monitor.lock);

    pthread_mutex_unlock(&self->tasks.monitor.lock);
  }

  if (self->tasks.orders.taskid != ERROR) {
    struct genom_activity *a;

    genom_log_debug("interrupting task orders");
    pthread_mutex_lock(&self->tasks.orders.lock);

    a = self->tasks.orders.permanent;
    if (!a) {
      /* activity was ether, realloc one */
      int i = genom_display_activity_alloc(
        &self->tasks.orders.activities);
      assert(i>=0);
      a = &self->tasks.orders.activities.a[i].any;
      a->sid = a->rid = -1;
    }
    if (a->status != ACT_STOP) {
      if (a->status == ACT_ETHER) a->status = ACT_INIT;
      a->stop = 1;
      a->interruptedby = "kill";
      self->tasks.orders.permanent = a;
      self->tasks.orders.runnable = 1;
      pthread_cond_broadcast(&self->tasks.orders.sync);
    }
    while(self->tasks.orders.permanent &&
          self->tasks.orders.permanent->status != ACT_ETHER)
      pthread_cond_wait(&self->tasks.orders.sync,
                        &self->tasks.orders.lock);

    pthread_mutex_unlock(&self->tasks.orders.lock);
  }

  /* wait for exec tasks */
  genom_log_debug("waiting task monitor");
  pthread_mutex_lock(&self->tasks.monitor.lock);
  self->tasks.monitor.shutdown = 1;
  self->tasks.monitor.runnable = 1;
  pthread_cond_broadcast(&self->tasks.monitor.sync);
  while (self->tasks.monitor.taskid != ERROR) {
    pthread_cond_wait(&self->tasks.monitor.sync,
                      &self->tasks.monitor.lock);
  }
  pthread_mutex_unlock(&self->tasks.monitor.lock);

  genom_log_debug("waiting task orders");
  pthread_mutex_lock(&self->tasks.orders.lock);
  self->tasks.orders.shutdown = 1;
  self->tasks.orders.runnable = 1;
  pthread_cond_broadcast(&self->tasks.orders.sync);
  while (self->tasks.orders.taskid != ERROR) {
    pthread_cond_wait(&self->tasks.orders.sync,
                      &self->tasks.orders.lock);
  }
  pthread_mutex_unlock(&self->tasks.orders.lock);


  /* wait for control task */
  if (self->control.taskid != ERROR) {
    genom_log_debug("waiting control task");
    pthread_mutex_lock(&self->control.lock);
    self->control.shutdown = 1;
    while (self->control.taskid != 0) {
      genom_display_schedule_cntrl(self);
      pthread_cond_wait(&self->control.sync, &self->control.lock);
    }
    pthread_mutex_unlock(&self->control.lock);
  }

  /* clean up */
  genom_display_genom_state_delete(&self->control.context);
  genom_display_genom_metadata_delete(&self->control.context);
  genom_display_JS_delete(&self->control.context);
  genom_display_IM_delete(&self->control.context);
  genom_display_AR_delete(&self->control.context);
  genom_display_POS_delete(&self->control.context);
  genom_display_BAT_delete(&self->control.context);

  genom_tfini_display_genom_state_port(&self->ports.genom_state);
  genom_tfini_display_genom_metadata_port(&self->ports.genom_metadata);
  genom_tfini_display_JS_port(&self->ports.JS);
  genom_tfini_display_IM_port(&self->ports.IM);
  genom_tfini_display_AR_port(&self->ports.AR);
  genom_tfini_display_POS_port(&self->ports.POS);
  genom_tfini_display_BAT_port(&self->ports.BAT);
  genom_tfini_t_display_ids(&self->ids);
  free(self);
  genom_log_info("shutdown complete");
}


/* --- genom_display_schedule_cntrl ------------------------------------- */

void
genom_display_schedule_cntrl(struct genom_component_data *self)
{
  if (self->control.taskid == ERROR) return;
  h2evnSignal(self->control.taskid);
}


/* --- display_cntrl_task(void) ----------------------------------------- */

static void *
display_cntrl_task(void *data)
{
  struct genom_component_data *self = data;
  int e;

  /* create requests reception mailbox */
  if (csMboxInit(self->control.mbox_name, DISPLAY_MBOX_RQST_SIZE, 0) != OK) {
    genom_log_warn(1, "cannot create server mailbox");
    pthread_mutex_lock(&self->control.lock);
    self->control.taskid = 0;
    pthread_cond_broadcast(&self->control.sync);
    pthread_mutex_unlock(&self->control.lock);
    return NULL;
  }

  /* configure as a server */
  if (csServInitN(
	DISPLAY_MAX_RQST_SIZE,
	DISPLAY_MAX_REPLY_SIZE >= DISPLAY_MAX_INTERMED_REPLY_SIZE ?
	DISPLAY_MAX_REPLY_SIZE : DISPLAY_MAX_INTERMED_REPLY_SIZE,
	DISPLAY_NRQSTID, &self->control.csserv) != OK) {
    genom_log_warn(1, "cannot initialize server mailbox");
    goto error;
  }
  /* fiddle with returned CS_SERV structure, to store ids for callbacks */
  self->control.csserv =
    realloc(self->control.csserv, sizeof(struct CS_SERV_IDS));
  ((struct CS_SERV_IDS *)self->control.csserv)->self = self;

  /* install services callbacks */
  if (csServFuncInstall(self->control.csserv, DISPLAY_abort_activity_RQSTID,
                        (FUNCPTR)display_abort_activity_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service abort_activity");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, DISPLAY_connect_port_RQSTID,
                        (FUNCPTR)display_connect_port_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service connect_port");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, DISPLAY_connect_service_RQSTID,
                        (FUNCPTR)display_connect_service_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service connect_service");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, DISPLAY_kill_RQSTID,
                        (FUNCPTR)display_kill_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service kill");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, DISPLAY_GetCurrentPosition_RQSTID,
                        (FUNCPTR)display_GetCurrentPosition_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service GetCurrentPosition");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, DISPLAY_GetCurrentBattery_RQSTID,
                        (FUNCPTR)display_GetCurrentBattery_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service GetCurrentBattery");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, DISPLAY_GetCurrentMap_RQSTID,
                        (FUNCPTR)display_GetCurrentMap_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service GetCurrentMap");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, DISPLAY_GetCurrentArena_RQSTID,
                        (FUNCPTR)display_GetCurrentArena_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service GetCurrentArena");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, DISPLAY_SendOrdersStop_RQSTID,
                        (FUNCPTR)display_SendOrdersStop_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service SendOrdersStop");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, DISPLAY_MonitoringStop_RQSTID,
                        (FUNCPTR)display_MonitoringStop_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service MonitoringStop");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, DISPLAY_SendOrders_RQSTID,
                        (FUNCPTR)display_SendOrders_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service SendOrders");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, DISPLAY_Monitoring_RQSTID,
                        (FUNCPTR)display_Monitoring_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service Monitoring");
    goto error;
  }

  /* signal parent */
  genom_log_info("spawned control task");
  pthread_mutex_lock(&self->control.lock);
  self->control.taskid = taskIdSelf();
  pthread_cond_broadcast(&self->control.sync);
  pthread_mutex_unlock(&self->control.lock);

  do {
    if (self->control.shutdown) {
      /* the task must sleep with h2evnSusp(), so there is no way to atomically
       * check for the shutdown flag. So do not bother taking the mutex.
       * The genom_display_fini() function will signal an h2evn, after
       * setting the shutdown flag, so it shouldn't exist any race. */
      break;
    }

    /* read reception mailbox status and sleep if there is no message */
    e = csMboxStatus(RCV_MBOX);
    switch(e) {
      case 0: /* no message */
        /* update state port before sleeping */
        genom_state_display_refresh(self);

        e = h2evnSusp(0);
        if (e != TRUE) {
          genom_log_warn(1, "someone did something nasty");
          genom_log_warn(0, "aborting");
          abort();
        }
        genom_log_debug("control task wake up");

        /* update reception mailbox status */
        e = csMboxStatus(RCV_MBOX);
        if (e != RCV_MBOX) /* awoken by internal event */ break;

        /*FALLTHROUGH*/
      case RCV_MBOX: /* incoming request */
        if (csServRqstExec(self->control.csserv) != OK) {
          genom_log_warn(1, "cannot read reception mailbox");
          genom_log_warn(0, "aborting");
          abort();
        }
        break;

      case ERROR:
        genom_log_warn(1, "cannot check reception mailbox");
        genom_log_warn(0, "aborting");
        abort();
    }


    /* process pending activities */
    pthread_mutex_lock(&self->tasks.orders.lock);
    {
      struct genom_activity *a;
      size_t id;

      for(id = 0; id < genom_max_activities(); id++) {
        a = &self->tasks.orders.activities.a[id].any;
        switch(a->status) {
          case ACT_VOID: case ACT_RUN: case ACT_STOP: continue;

          case ACT_INIT: {
            int delay;
            if (!a->start) {
              pthread_mutex_unlock(&self->tasks.orders.lock);
              delay = genom_display_interrupt_reqd(self, a);
              pthread_mutex_lock(&self->tasks.orders.lock);
              if (!delay) {
                a->start = 1;
                if (!self->tasks.orders.runnable) {
                  self->tasks.orders.runnable = 1;
                  pthread_cond_broadcast(&self->tasks.orders.sync);
                }
              }
            }
            break;
          }

          case ACT_ETHER:
            if (a == self->tasks.orders.permanent)
              self->tasks.orders.permanent = NULL;
            else {
              pthread_mutex_unlock(&self->tasks.orders.lock);
              genom_display_activity_report(self, a);
              pthread_mutex_lock(&self->tasks.orders.lock);
            }
            a->status = ACT_VOID;
            genom_state_display_update(
              self, &self->tasks.orders.activities,
              display_orders_TASKID);
            break;
        }
      }
    }
    pthread_mutex_unlock(&self->tasks.orders.lock);
    pthread_mutex_lock(&self->tasks.monitor.lock);
    {
      struct genom_activity *a;
      size_t id;

      for(id = 0; id < genom_max_activities(); id++) {
        a = &self->tasks.monitor.activities.a[id].any;
        switch(a->status) {
          case ACT_VOID: case ACT_RUN: case ACT_STOP: continue;

          case ACT_INIT: {
            int delay;
            if (!a->start) {
              pthread_mutex_unlock(&self->tasks.monitor.lock);
              delay = genom_display_interrupt_reqd(self, a);
              pthread_mutex_lock(&self->tasks.monitor.lock);
              if (!delay) {
                a->start = 1;
                if (!self->tasks.monitor.runnable) {
                  self->tasks.monitor.runnable = 1;
                  pthread_cond_broadcast(&self->tasks.monitor.sync);
                }
              }
            }
            break;
          }

          case ACT_ETHER:
            if (a == self->tasks.monitor.permanent)
              self->tasks.monitor.permanent = NULL;
            else {
              pthread_mutex_unlock(&self->tasks.monitor.lock);
              genom_display_activity_report(self, a);
              pthread_mutex_lock(&self->tasks.monitor.lock);
            }
            a->status = ACT_VOID;
            genom_state_display_update(
              self, &self->tasks.monitor.activities,
              display_monitor_TASKID);
            break;
        }
      }
    }
    pthread_mutex_unlock(&self->tasks.monitor.lock);
  } while(1);

  genom_log_info("shutting down control task");

error:
  if (self->control.csserv) csServEnd(self->control.csserv);
  csMboxEnd();

  pthread_mutex_lock(&self->control.lock);
  self->control.taskid = 0;
  pthread_cond_broadcast(&self->control.sync);
  pthread_mutex_unlock(&self->control.lock);
  return NULL;
}


/* --- Service callbacks --------------------------------------------------- */


static void
display_abort_activity_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_display_abort_activity_activity *a;
  STATUS s;

  genom_log_debug("handling request for abort_activity");

  /* get an activity slot */
  a = &self->control.activity.s_abort_activity;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = DISPLAY_abort_activity_RQSTID;
  a->h.rid = rid;
  genom_tinit_display_abort_activity_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_display_abort_activity_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "abort_activity");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_display_abort_activity_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.orders.lock);
  if (!self->tasks.orders.runnable) {
    self->tasks.orders.runnable = 1;
    pthread_cond_broadcast(&self->tasks.orders.sync);
  }
  pthread_mutex_unlock(&self->tasks.orders.lock);
  pthread_mutex_lock(&self->tasks.monitor.lock);
  if (!self->tasks.monitor.runnable) {
    self->tasks.monitor.runnable = 1;
    pthread_cond_broadcast(&self->tasks.monitor.sync);
  }
  pthread_mutex_unlock(&self->tasks.monitor.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_display_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[DISPLAY_abort_activity_RQSTID] = 1;

  /* send final reply */
  a->h.state = display_ether;
  genom_display_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
display_connect_port_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_display_connect_port_activity *a;
  STATUS s;

  genom_log_debug("handling request for connect_port");

  /* get an activity slot */
  a = &self->control.activity.s_connect_port;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = DISPLAY_connect_port_RQSTID;
  a->h.rid = rid;
  genom_tinit_display_connect_port_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_display_connect_port_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "connect_port");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_display_connect_port_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.orders.lock);
  if (!self->tasks.orders.runnable) {
    self->tasks.orders.runnable = 1;
    pthread_cond_broadcast(&self->tasks.orders.sync);
  }
  pthread_mutex_unlock(&self->tasks.orders.lock);
  pthread_mutex_lock(&self->tasks.monitor.lock);
  if (!self->tasks.monitor.runnable) {
    self->tasks.monitor.runnable = 1;
    pthread_cond_broadcast(&self->tasks.monitor.sync);
  }
  pthread_mutex_unlock(&self->tasks.monitor.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_display_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[DISPLAY_connect_port_RQSTID] = 1;

  /* send final reply */
  a->h.state = display_ether;
  genom_display_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
display_connect_service_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_display_connect_service_activity *a;
  STATUS s;

  genom_log_debug("handling request for connect_service");

  /* get an activity slot */
  a = &self->control.activity.s_connect_service;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = DISPLAY_connect_service_RQSTID;
  a->h.rid = rid;
  genom_tinit_display_connect_service_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_display_connect_service_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "connect_service");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_display_connect_service_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.orders.lock);
  if (!self->tasks.orders.runnable) {
    self->tasks.orders.runnable = 1;
    pthread_cond_broadcast(&self->tasks.orders.sync);
  }
  pthread_mutex_unlock(&self->tasks.orders.lock);
  pthread_mutex_lock(&self->tasks.monitor.lock);
  if (!self->tasks.monitor.runnable) {
    self->tasks.monitor.runnable = 1;
    pthread_cond_broadcast(&self->tasks.monitor.sync);
  }
  pthread_mutex_unlock(&self->tasks.monitor.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_display_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[DISPLAY_connect_service_RQSTID] = 1;

  /* send final reply */
  a->h.state = display_ether;
  genom_display_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
display_kill_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_display_kill_activity *a;
  STATUS s;

  genom_log_debug("handling request for kill");

  /* get an activity slot */
  a = &self->control.activity.s_kill;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = DISPLAY_kill_RQSTID;
  a->h.rid = rid;
  genom_tinit_display_kill_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_display_kill_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "kill");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_display_kill_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.orders.lock);
  if (!self->tasks.orders.runnable) {
    self->tasks.orders.runnable = 1;
    pthread_cond_broadcast(&self->tasks.orders.sync);
  }
  pthread_mutex_unlock(&self->tasks.orders.lock);
  pthread_mutex_lock(&self->tasks.monitor.lock);
  if (!self->tasks.monitor.runnable) {
    self->tasks.monitor.runnable = 1;
    pthread_cond_broadcast(&self->tasks.monitor.sync);
  }
  pthread_mutex_unlock(&self->tasks.monitor.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_display_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[DISPLAY_kill_RQSTID] = 1;

  /* send final reply */
  a->h.state = display_ether;
  genom_display_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
display_GetCurrentPosition_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_display_GetCurrentPosition_activity *a;
  STATUS s;

  genom_log_debug("handling request for GetCurrentPosition");

  /* get an activity slot */
  a = &self->control.activity.s_GetCurrentPosition;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = DISPLAY_GetCurrentPosition_RQSTID;
  a->h.rid = rid;
  genom_tinit_display_GetCurrentPosition_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_display_GetCurrentPosition_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "GetCurrentPosition");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_display_GetCurrentPosition_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.orders.lock);
  if (!self->tasks.orders.runnable) {
    self->tasks.orders.runnable = 1;
    pthread_cond_broadcast(&self->tasks.orders.sync);
  }
  pthread_mutex_unlock(&self->tasks.orders.lock);
  pthread_mutex_lock(&self->tasks.monitor.lock);
  if (!self->tasks.monitor.runnable) {
    self->tasks.monitor.runnable = 1;
    pthread_cond_broadcast(&self->tasks.monitor.sync);
  }
  pthread_mutex_unlock(&self->tasks.monitor.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_display_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[DISPLAY_GetCurrentPosition_RQSTID] = 1;

  /* send final reply */
  a->h.state = display_ether;
  genom_display_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
display_GetCurrentBattery_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_display_GetCurrentBattery_activity *a;
  STATUS s;

  genom_log_debug("handling request for GetCurrentBattery");

  /* get an activity slot */
  a = &self->control.activity.s_GetCurrentBattery;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = DISPLAY_GetCurrentBattery_RQSTID;
  a->h.rid = rid;
  genom_tinit_display_GetCurrentBattery_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_display_GetCurrentBattery_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "GetCurrentBattery");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_display_GetCurrentBattery_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.orders.lock);
  if (!self->tasks.orders.runnable) {
    self->tasks.orders.runnable = 1;
    pthread_cond_broadcast(&self->tasks.orders.sync);
  }
  pthread_mutex_unlock(&self->tasks.orders.lock);
  pthread_mutex_lock(&self->tasks.monitor.lock);
  if (!self->tasks.monitor.runnable) {
    self->tasks.monitor.runnable = 1;
    pthread_cond_broadcast(&self->tasks.monitor.sync);
  }
  pthread_mutex_unlock(&self->tasks.monitor.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_display_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[DISPLAY_GetCurrentBattery_RQSTID] = 1;

  /* send final reply */
  a->h.state = display_ether;
  genom_display_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
display_GetCurrentMap_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_display_GetCurrentMap_activity *a;
  STATUS s;

  genom_log_debug("handling request for GetCurrentMap");

  /* get an activity slot */
  a = &self->control.activity.s_GetCurrentMap;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = DISPLAY_GetCurrentMap_RQSTID;
  a->h.rid = rid;
  genom_tinit_display_GetCurrentMap_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_display_GetCurrentMap_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "GetCurrentMap");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_display_GetCurrentMap_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.orders.lock);
  if (!self->tasks.orders.runnable) {
    self->tasks.orders.runnable = 1;
    pthread_cond_broadcast(&self->tasks.orders.sync);
  }
  pthread_mutex_unlock(&self->tasks.orders.lock);
  pthread_mutex_lock(&self->tasks.monitor.lock);
  if (!self->tasks.monitor.runnable) {
    self->tasks.monitor.runnable = 1;
    pthread_cond_broadcast(&self->tasks.monitor.sync);
  }
  pthread_mutex_unlock(&self->tasks.monitor.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_display_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[DISPLAY_GetCurrentMap_RQSTID] = 1;

  /* send final reply */
  a->h.state = display_ether;
  genom_display_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
display_GetCurrentArena_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_display_GetCurrentArena_activity *a;
  STATUS s;

  genom_log_debug("handling request for GetCurrentArena");

  /* get an activity slot */
  a = &self->control.activity.s_GetCurrentArena;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = DISPLAY_GetCurrentArena_RQSTID;
  a->h.rid = rid;
  genom_tinit_display_GetCurrentArena_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_display_GetCurrentArena_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "GetCurrentArena");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_display_GetCurrentArena_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.orders.lock);
  if (!self->tasks.orders.runnable) {
    self->tasks.orders.runnable = 1;
    pthread_cond_broadcast(&self->tasks.orders.sync);
  }
  pthread_mutex_unlock(&self->tasks.orders.lock);
  pthread_mutex_lock(&self->tasks.monitor.lock);
  if (!self->tasks.monitor.runnable) {
    self->tasks.monitor.runnable = 1;
    pthread_cond_broadcast(&self->tasks.monitor.sync);
  }
  pthread_mutex_unlock(&self->tasks.monitor.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_display_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[DISPLAY_GetCurrentArena_RQSTID] = 1;

  /* send final reply */
  a->h.state = display_ether;
  genom_display_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
display_SendOrdersStop_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_display_SendOrdersStop_activity *a;
  STATUS s;

  genom_log_debug("handling request for SendOrdersStop");

  /* get an activity slot */
  a = &self->control.activity.s_SendOrdersStop;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = DISPLAY_SendOrdersStop_RQSTID;
  a->h.rid = rid;
  genom_tinit_display_SendOrdersStop_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_display_SendOrdersStop_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "SendOrdersStop");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_display_SendOrdersStop_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.orders.lock);
  if (!self->tasks.orders.runnable) {
    self->tasks.orders.runnable = 1;
    pthread_cond_broadcast(&self->tasks.orders.sync);
  }
  pthread_mutex_unlock(&self->tasks.orders.lock);
  pthread_mutex_lock(&self->tasks.monitor.lock);
  if (!self->tasks.monitor.runnable) {
    self->tasks.monitor.runnable = 1;
    pthread_cond_broadcast(&self->tasks.monitor.sync);
  }
  pthread_mutex_unlock(&self->tasks.monitor.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_display_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[DISPLAY_SendOrdersStop_RQSTID] = 1;

  /* send final reply */
  a->h.state = display_ether;
  genom_display_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
display_MonitoringStop_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_display_MonitoringStop_activity *a;
  STATUS s;

  genom_log_debug("handling request for MonitoringStop");

  /* get an activity slot */
  a = &self->control.activity.s_MonitoringStop;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = DISPLAY_MonitoringStop_RQSTID;
  a->h.rid = rid;
  genom_tinit_display_MonitoringStop_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_display_MonitoringStop_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "MonitoringStop");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_display_MonitoringStop_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.orders.lock);
  if (!self->tasks.orders.runnable) {
    self->tasks.orders.runnable = 1;
    pthread_cond_broadcast(&self->tasks.orders.sync);
  }
  pthread_mutex_unlock(&self->tasks.orders.lock);
  pthread_mutex_lock(&self->tasks.monitor.lock);
  if (!self->tasks.monitor.runnable) {
    self->tasks.monitor.runnable = 1;
    pthread_cond_broadcast(&self->tasks.monitor.sync);
  }
  pthread_mutex_unlock(&self->tasks.monitor.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_display_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[DISPLAY_MonitoringStop_RQSTID] = 1;

  /* send final reply */
  a->h.state = display_ether;
  genom_display_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
display_SendOrders_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_display_SendOrders_activity *a;
  STATUS s;

  genom_log_debug("handling request for SendOrders");

  /* get an activity slot */
  pthread_mutex_lock(&self->tasks.orders.lock);
  int id = genom_display_activity_alloc(&self->tasks.orders.activities);
  if (id < 0) {
    pthread_mutex_unlock(&self->tasks.orders.lock);
    s = csServReplySend(
      csserv, rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_display_genom_too_many_activities_encodex);
    if (s == ERROR) assert(!"unexpected failure");
    return;
  }
  a = &self->tasks.orders.activities.a[id].s_SendOrders;
  pthread_mutex_unlock(&self->tasks.orders.lock);
  a->h.sid = DISPLAY_SendOrders_RQSTID;
  a->h.rid = rid;
  genom_tinit_display_SendOrders_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_display_SendOrders_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "SendOrders");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_display_SendOrders_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.orders.lock);
  if (!self->tasks.orders.runnable) {
    self->tasks.orders.runnable = 1;
    pthread_cond_broadcast(&self->tasks.orders.sync);
  }
  pthread_mutex_unlock(&self->tasks.orders.lock);
  pthread_mutex_lock(&self->tasks.monitor.lock);
  if (!self->tasks.monitor.runnable) {
    self->tasks.monitor.runnable = 1;
    pthread_cond_broadcast(&self->tasks.monitor.sync);
  }
  pthread_mutex_unlock(&self->tasks.monitor.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* update state port */
  pthread_mutex_lock(&self->tasks.orders.lock);
  genom_state_display_update(
              self, &self->tasks.orders.activities,
              display_orders_TASKID);
  pthread_mutex_unlock(&self->tasks.orders.lock);

  /* send intermediate reply */
  s = csServReplySend(csserv, rid, INTERMED_REPLY, OK,
                      (char *)&a->h.aid, sizeof(int), NULL);
  if (s == ERROR) {
    genom_log_warn(1, "cannot acknowledge service %s", "SendOrders");
  }

  return;

clean:
  assert(a->h.status == ACT_INIT);
  pthread_mutex_lock(&self->tasks.orders.lock);
  a->h.status = ACT_VOID;
  pthread_mutex_unlock(&self->tasks.orders.lock);
}


static void
display_Monitoring_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_display_Monitoring_activity *a;
  STATUS s;

  genom_log_debug("handling request for Monitoring");

  /* get an activity slot */
  pthread_mutex_lock(&self->tasks.monitor.lock);
  int id = genom_display_activity_alloc(&self->tasks.monitor.activities);
  if (id < 0) {
    pthread_mutex_unlock(&self->tasks.monitor.lock);
    s = csServReplySend(
      csserv, rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_display_genom_too_many_activities_encodex);
    if (s == ERROR) assert(!"unexpected failure");
    return;
  }
  a = &self->tasks.monitor.activities.a[id].s_Monitoring;
  pthread_mutex_unlock(&self->tasks.monitor.lock);
  a->h.sid = DISPLAY_Monitoring_RQSTID;
  a->h.rid = rid;
  genom_tinit_display_Monitoring_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_display_Monitoring_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "Monitoring");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_display_Monitoring_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.orders.lock);
  if (!self->tasks.orders.runnable) {
    self->tasks.orders.runnable = 1;
    pthread_cond_broadcast(&self->tasks.orders.sync);
  }
  pthread_mutex_unlock(&self->tasks.orders.lock);
  pthread_mutex_lock(&self->tasks.monitor.lock);
  if (!self->tasks.monitor.runnable) {
    self->tasks.monitor.runnable = 1;
    pthread_cond_broadcast(&self->tasks.monitor.sync);
  }
  pthread_mutex_unlock(&self->tasks.monitor.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_display_activity_report(self, &a->h);
    goto clean;
  }

  /* update state port */
  pthread_mutex_lock(&self->tasks.monitor.lock);
  genom_state_display_update(
              self, &self->tasks.monitor.activities,
              display_monitor_TASKID);
  pthread_mutex_unlock(&self->tasks.monitor.lock);

  /* send intermediate reply */
  s = csServReplySend(csserv, rid, INTERMED_REPLY, OK,
                      (char *)&a->h.aid, sizeof(int), NULL);
  if (s == ERROR) {
    genom_log_warn(1, "cannot acknowledge service %s", "Monitoring");
  }

  return;

clean:
  assert(a->h.status == ACT_INIT);
  pthread_mutex_lock(&self->tasks.monitor.lock);
  a->h.status = ACT_VOID;
  pthread_mutex_unlock(&self->tasks.monitor.lock);
}


/* eof */

/* --- Generated by genom 2.99.29. Do not edit -------------------------- */

#include "autoconf/acheader.h"

#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>

#include "h2devLib.h"

#include "display_control_task.h"
#include "display_portlib.h"
#include "serialize.h"

/* --- local data ---------------------------------------------------------- */

enum {
  display_PORTLIB_MIN_INDEX = 0,
  display_genom_state_INDEX,
  display_genom_metadata_INDEX,
  display_JS_INDEX,
  display_IM_INDEX,
  display_AR_INDEX,
  display_POS_INDEX,
  display_BAT_INDEX,
  display_PORTLIB_MAX_INDEX
};

/* --- state port ---------------------------------------------------------- */

int
genom_state_display_init(struct genom_component_data *self)
{
  genom_state_component *data = &self->ports.genom_state.h.buffer;

  /* task list */
  if (genom_sequence_reserve(&data->task, 2))
    return ENOMEM;
  {
    genom_state_task *task;
    task = &data->task._buffer[display_orders_TASKID];

    snprintf(task->name, sizeof(task->name), "%s", "orders");
    task->rusage.cycles = 0;
    task->rusage.timings.last = 0;
    task->rusage.timings.max = 0;
    task->rusage.timings.avg = 0;
    task->rusage.load.last = 0;
    task->rusage.load.max = 0;
    task->rusage.load.avg = 0;
    task->activity._length = 0;
    if (genom_sequence_reserve(&task->activity, genom_max_activities()))
      return ENOMEM;
  }
  {
    genom_state_task *task;
    task = &data->task._buffer[display_monitor_TASKID];

    snprintf(task->name, sizeof(task->name), "%s", "monitor");
    task->rusage.cycles = 0;
    task->rusage.timings.last = 0;
    task->rusage.timings.max = 0;
    task->rusage.timings.avg = 0;
    task->rusage.load.last = 0;
    task->rusage.load.max = 0;
    task->rusage.load.avg = 0;
    task->activity._length = 0;
    if (genom_sequence_reserve(&task->activity, genom_max_activities()))
      return ENOMEM;
  }
  data->task._length = 2;

  /* automatic versioning - nice idea borrowed from ROS */
  strncpy(data->digest, "2b3c8b494e9cca5e27b57a6835b5652", sizeof(data->digest));
  strncpy(data->date, "Thu Jul 20 15:19:46 CEST 2017", sizeof(data->date));
  strncpy(data->version, "1.0", sizeof(data->version));

  genom_log_debug("initialized genom_state port");
  return 0;
}

int
genom_state_display_update(struct genom_component_data *self,
                    struct genom_activities *activities, int tnum)
{
  genom_state_component *data = &self->ports.genom_state.h.buffer;
  genom_state_task *t = &data->task._buffer[tnum];
  struct genom_activity *a;
  const char *s;
  size_t i, j;

  for(i = j = 0; i < genom_max_activities(); i++) {
    a = &activities->a[i].any;
    if (a->status == ACT_VOID) continue;

    t->activity._buffer[j].id = a->aid;
    switch(a->sid) {
      case -1: s = "<task>"; break;
      case DISPLAY_SendOrders_RQSTID: s = "SendOrders"; break;
      case DISPLAY_Monitoring_RQSTID: s = "Monitoring"; break;
      default: assert(!"unknown service id"); break;
    }
    snprintf(t->activity._buffer[j].name,
             sizeof(t->activity._buffer[j].name), "%s", s);
    j++;
  }
  t->activity._length = j;
  return 0;
}

genom_event
genom_state_display_refresh(struct genom_component_data *self)
{
  genom_state_component *data = &self->ports.genom_state.h.buffer;
  genom_state_task *task;
  genom_event s;

  /* task rusage */
  task = &data->task._buffer[display_orders_TASKID];
  pthread_spin_lock(&self->tasks.orders.rlock);
  task->rusage = self->tasks.orders.rusage;
  pthread_spin_unlock(&self->tasks.orders.rlock);
  task = &data->task._buffer[display_monitor_TASKID];
  pthread_spin_lock(&self->tasks.monitor.rlock);
  task->rusage = self->tasks.monitor.rusage;
  pthread_spin_unlock(&self->tasks.monitor.rlock);

  s = self->ports.genom_state.handle.write(&self->control.context);
  if (s) genom_log_warn(0, "cannot update state port: %s", s);
  genom_log_debug("refreshed genom_state port");
  return s;
}


/* --- metadata port ------------------------------------------------------- */

int
genom_metadata_display_init(struct genom_component_data *self)
{
  pocolibs_metadata_component *meta = &self->ports.genom_metadata.h.buffer;
  size_t l, m;

  genom_sequence_reserve(&meta->services, 12);
  l = sizeof(meta->services._buffer->name);
  m = sizeof(meta->services._buffer->digest);
  meta->services._buffer[0].rqstid = DISPLAY_abort_activity_RQSTID;
  strncpy(meta->services._buffer[0].name, "abort_activity", l);
  meta->services._buffer[0].name[l-1] = 0;
  strncpy(meta->services._buffer[0].digest, "4385b2f03ea2fe81a32b92a3c0e940", m);
  meta->services._buffer[0].digest[m-1] = 0;
  meta->services._buffer[1].rqstid = DISPLAY_connect_port_RQSTID;
  strncpy(meta->services._buffer[1].name, "connect_port", l);
  meta->services._buffer[1].name[l-1] = 0;
  strncpy(meta->services._buffer[1].digest, "4c1bd913585cd1265c6ad7aea00421a", m);
  meta->services._buffer[1].digest[m-1] = 0;
  meta->services._buffer[2].rqstid = DISPLAY_connect_service_RQSTID;
  strncpy(meta->services._buffer[2].name, "connect_service", l);
  meta->services._buffer[2].name[l-1] = 0;
  strncpy(meta->services._buffer[2].digest, "4c1bd913585cd1265c6ad7aea00421a", m);
  meta->services._buffer[2].digest[m-1] = 0;
  meta->services._buffer[3].rqstid = DISPLAY_kill_RQSTID;
  strncpy(meta->services._buffer[3].name, "kill", l);
  meta->services._buffer[3].name[l-1] = 0;
  strncpy(meta->services._buffer[3].digest, "62357408c1c53751884a1c27b10599", m);
  meta->services._buffer[3].digest[m-1] = 0;
  meta->services._buffer[4].rqstid = DISPLAY_GetCurrentPosition_RQSTID;
  strncpy(meta->services._buffer[4].name, "GetCurrentPosition", l);
  meta->services._buffer[4].name[l-1] = 0;
  strncpy(meta->services._buffer[4].digest, "4a7ce31639d5e05d5e3d642b206af6f0", m);
  meta->services._buffer[4].digest[m-1] = 0;
  meta->services._buffer[5].rqstid = DISPLAY_GetCurrentBattery_RQSTID;
  strncpy(meta->services._buffer[5].name, "GetCurrentBattery", l);
  meta->services._buffer[5].name[l-1] = 0;
  strncpy(meta->services._buffer[5].digest, "4ac9b8894418a39cd852ecf5cb9d143", m);
  meta->services._buffer[5].digest[m-1] = 0;
  meta->services._buffer[6].rqstid = DISPLAY_GetCurrentMap_RQSTID;
  strncpy(meta->services._buffer[6].name, "GetCurrentMap", l);
  meta->services._buffer[6].name[l-1] = 0;
  strncpy(meta->services._buffer[6].digest, "fc57e3ba53274515a776b67d2eda0e8", m);
  meta->services._buffer[6].digest[m-1] = 0;
  meta->services._buffer[7].rqstid = DISPLAY_GetCurrentArena_RQSTID;
  strncpy(meta->services._buffer[7].name, "GetCurrentArena", l);
  meta->services._buffer[7].name[l-1] = 0;
  strncpy(meta->services._buffer[7].digest, "9ff443adc235e91e47b553fa5bbf", m);
  meta->services._buffer[7].digest[m-1] = 0;
  meta->services._buffer[8].rqstid = DISPLAY_SendOrdersStop_RQSTID;
  strncpy(meta->services._buffer[8].name, "SendOrdersStop", l);
  meta->services._buffer[8].name[l-1] = 0;
  strncpy(meta->services._buffer[8].digest, "62357408c1c53751884a1c27b10599", m);
  meta->services._buffer[8].digest[m-1] = 0;
  meta->services._buffer[9].rqstid = DISPLAY_MonitoringStop_RQSTID;
  strncpy(meta->services._buffer[9].name, "MonitoringStop", l);
  meta->services._buffer[9].name[l-1] = 0;
  strncpy(meta->services._buffer[9].digest, "62357408c1c53751884a1c27b10599", m);
  meta->services._buffer[9].digest[m-1] = 0;
  meta->services._buffer[10].rqstid = DISPLAY_SendOrders_RQSTID;
  strncpy(meta->services._buffer[10].name, "SendOrders", l);
  meta->services._buffer[10].name[l-1] = 0;
  strncpy(meta->services._buffer[10].digest, "62357408c1c53751884a1c27b10599", m);
  meta->services._buffer[10].digest[m-1] = 0;
  meta->services._buffer[11].rqstid = DISPLAY_Monitoring_RQSTID;
  strncpy(meta->services._buffer[11].name, "Monitoring", l);
  meta->services._buffer[11].name[l-1] = 0;
  strncpy(meta->services._buffer[11].digest, "62357408c1c53751884a1c27b10599", m);
  meta->services._buffer[11].digest[m-1] = 0;
  meta->services._length = 12;

  genom_log_debug("initialized metadata port");
  return 0;
}

genom_event
genom_metadata_display_fetch(struct genom_component_data *self,
                      const char *comp, pocolibs_metadata_component *meta)
{
  char name[H2_DEV_MAX_NAME];
  POSTER_ID id;
  char *data;
  STATUS s;
  ssize_t m;
  int n;

  n = snprintf(name, sizeof(name), "%s/genom_metadata", comp);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port %s name too long", name);
    genom_log_warn(0, "port name length limited to %d characters",
                   H2_DEV_MAX_NAME);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG },
                        &self->control.context);
  }

  if (posterFind(name, &id) != OK) {
    genom_log_warn(1, "no such port %s", name);
    return genom_no_such_service(&self->control.context);
  }

  s = posterTake(id, POSTER_READ);
  if (s != OK) {
    genom_log_warn(1, "cannot access metadata port %s", name);
    return genom_no_such_service(&self->control.context);
  }

  data = posterAddr(id);
  m = -1;
  s =
    genom_deserialize_t_pocolibs_metadata_component
    (&data, &m, meta);
  if (s) {
    genom_log_warn(1, "cannot read metadata port %s contents", name);
    return genom_no_such_service(&self->control.context);
  }
  posterGive(id);

  return 0;
}



/* --- genom_display_genom_state_get_ph --------------------------------- */

static __inline__ struct genom_display_genom_state_ph *
genom_display_genom_state_get_ph(
  struct genom_display_genom_state_port *p)
{
  return &p->h;
}


/* --- genom_display_genom_state_data ----------------------------------- */

genom_state_component *
genom_display_genom_state_data(
  genom_context self)
{
  struct genom_display_genom_state_port *p;
  struct genom_display_genom_state_ph *ph;

  p = &self->data->self->ports.genom_state;

  ph = genom_display_genom_state_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_display_genom_state_open ----------------------------------- */

genom_event
genom_display_genom_state_open(
  genom_context self)
{
  struct genom_display_genom_state_port *p;
  struct genom_display_genom_state_ph *ph;
  char name[H2_DEV_MAX_NAME];
  STATUS s;
  size_t l;
  int n;

  p = &self->data->self->ports.genom_state;

  n = snprintf(name, sizeof(name), "%s/genom_state", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port genom_state name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  l = genom_maxserialen_t_genom_state_component();

  s = posterCreate(name, (int)l, &ph->id);
  if (s == ERROR) {
    genom_log_warn(1, "cannot create outport %s", name);
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);
  }
  ph->size = l;
  genom_log_info("created outport %s", name);
  return genom_ok;
}


/* --- genom_display_genom_state_close ---------------------------------- */

genom_event
genom_display_genom_state_close(
  genom_context self)
{
  struct genom_display_genom_state_port *p;
  struct genom_display_genom_state_ph *ph;

  p = &self->data->self->ports.genom_state;

  ph = genom_display_genom_state_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  posterDelete(ph->id);
  genom_log_info("destroyed outport genom_state");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_display_genom_state_delete --------------------------------- */

void
genom_display_genom_state_delete(genom_context self)
{
  genom_display_genom_state_close(self);
}


/* --- genom_display_genom_metadata_get_ph ------------------------------ */

static __inline__ struct genom_display_genom_metadata_ph *
genom_display_genom_metadata_get_ph(
  struct genom_display_genom_metadata_port *p)
{
  return &p->h;
}


/* --- genom_display_genom_metadata_data -------------------------------- */

pocolibs_metadata_component *
genom_display_genom_metadata_data(
  genom_context self)
{
  struct genom_display_genom_metadata_port *p;
  struct genom_display_genom_metadata_ph *ph;

  p = &self->data->self->ports.genom_metadata;

  ph = genom_display_genom_metadata_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_display_genom_metadata_open -------------------------------- */

genom_event
genom_display_genom_metadata_open(
  genom_context self)
{
  struct genom_display_genom_metadata_port *p;
  struct genom_display_genom_metadata_ph *ph;
  char name[H2_DEV_MAX_NAME];
  STATUS s;
  size_t l;
  int n;

  p = &self->data->self->ports.genom_metadata;

  n = snprintf(name, sizeof(name), "%s/genom_metadata", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port genom_metadata name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  l = genom_maxserialen_t_pocolibs_metadata_component();

  s = posterCreate(name, (int)l, &ph->id);
  if (s == ERROR) {
    genom_log_warn(1, "cannot create outport %s", name);
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);
  }
  ph->size = l;
  genom_log_info("created outport %s", name);
  return genom_ok;
}


/* --- genom_display_genom_metadata_close ------------------------------- */

genom_event
genom_display_genom_metadata_close(
  genom_context self)
{
  struct genom_display_genom_metadata_port *p;
  struct genom_display_genom_metadata_ph *ph;

  p = &self->data->self->ports.genom_metadata;

  ph = genom_display_genom_metadata_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  posterDelete(ph->id);
  genom_log_info("destroyed outport genom_metadata");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_display_genom_metadata_delete ------------------------------ */

void
genom_display_genom_metadata_delete(genom_context self)
{
  genom_display_genom_metadata_close(self);
}


/* --- genom_display_JS_get_ph ------------------------------------------ */

static __inline__ struct genom_display_JS_ph *
genom_display_JS_get_ph(
  struct genom_display_JS_port *p)
{
  return &p->h;
}


/* --- genom_display_JS_data -------------------------------------------- */

display_order *
genom_display_JS_data(
  genom_context self)
{
  struct genom_display_JS_port *p;
  struct genom_display_JS_ph *ph;

  p = &self->data->self->ports.JS;

  ph = genom_display_JS_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_display_JS_open -------------------------------------------- */

genom_event
genom_display_JS_open(
  genom_context self)
{
  struct genom_display_JS_port *p;
  struct genom_display_JS_ph *ph;
  char name[H2_DEV_MAX_NAME];
  STATUS s;
  size_t l;
  int n;

  p = &self->data->self->ports.JS;

  n = snprintf(name, sizeof(name), "%s/JS", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port JS name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  l = genom_maxserialen_t_display_order();

  s = posterCreate(name, (int)l, &ph->id);
  if (s == ERROR) {
    genom_log_warn(1, "cannot create outport %s", name);
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);
  }
  ph->size = l;
  genom_log_info("created outport %s", name);
  return genom_ok;
}


/* --- genom_display_JS_close ------------------------------------------- */

genom_event
genom_display_JS_close(
  genom_context self)
{
  struct genom_display_JS_port *p;
  struct genom_display_JS_ph *ph;

  p = &self->data->self->ports.JS;

  ph = genom_display_JS_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  posterDelete(ph->id);
  genom_log_info("destroyed outport JS");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_display_JS_delete ------------------------------------------ */

void
genom_display_JS_delete(genom_context self)
{
  genom_display_JS_close(self);
}


/* --- genom_display_IM_get_ph ------------------------------------------ */

static __inline__ struct genom_display_IM_ph *
genom_display_IM_get_ph(
  struct genom_display_IM_port *p)
{
  return &p->h;
}


/* --- genom_display_IM_data -------------------------------------------- */

camera_map *
genom_display_IM_data(
  genom_context self)
{
  struct genom_display_IM_port *p;
  struct genom_display_IM_ph *ph;

  p = &self->data->self->ports.IM;

  ph = genom_display_IM_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_display_IM_open -------------------------------------------- */

genom_event
genom_display_IM_open(
  genom_context self)
{
  struct genom_display_IM_port *p;
  struct genom_display_IM_ph *ph;
  char name[H2_DEV_MAX_NAME];
  int n;

  p = &self->data->self->ports.IM;

  n = snprintf(name, sizeof(name), "%s/IM", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port IM name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  genom_log_info("created inport %s", name);
  return genom_ok;
}


/* --- genom_display_IM_close ------------------------------------------- */

genom_event
genom_display_IM_close(
  genom_context self)
{
  struct genom_display_IM_port *p;
  struct genom_display_IM_ph *ph;

  p = &self->data->self->ports.IM;

  ph = genom_display_IM_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  genom_log_info("destroyed inport IM");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_display_IM_delete ------------------------------------------ */

void
genom_display_IM_delete(genom_context self)
{
  genom_display_IM_close(self);
}


/* --- genom_display_AR_get_ph ------------------------------------------ */

static __inline__ struct genom_display_AR_ph *
genom_display_AR_get_ph(
  struct genom_display_AR_port *p)
{
  return &p->h;
}


/* --- genom_display_AR_data -------------------------------------------- */

camera_arena *
genom_display_AR_data(
  genom_context self)
{
  struct genom_display_AR_port *p;
  struct genom_display_AR_ph *ph;

  p = &self->data->self->ports.AR;

  ph = genom_display_AR_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_display_AR_open -------------------------------------------- */

genom_event
genom_display_AR_open(
  genom_context self)
{
  struct genom_display_AR_port *p;
  struct genom_display_AR_ph *ph;
  char name[H2_DEV_MAX_NAME];
  int n;

  p = &self->data->self->ports.AR;

  n = snprintf(name, sizeof(name), "%s/AR", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port AR name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  genom_log_info("created inport %s", name);
  return genom_ok;
}


/* --- genom_display_AR_close ------------------------------------------- */

genom_event
genom_display_AR_close(
  genom_context self)
{
  struct genom_display_AR_port *p;
  struct genom_display_AR_ph *ph;

  p = &self->data->self->ports.AR;

  ph = genom_display_AR_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  genom_log_info("destroyed inport AR");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_display_AR_delete ------------------------------------------ */

void
genom_display_AR_delete(genom_context self)
{
  genom_display_AR_close(self);
}


/* --- genom_display_POS_get_ph ----------------------------------------- */

static __inline__ struct genom_display_POS_ph *
genom_display_POS_get_ph(
  struct genom_display_POS_port *p)
{
  return &p->h;
}


/* --- genom_display_POS_data ------------------------------------------- */

camera_robot *
genom_display_POS_data(
  genom_context self)
{
  struct genom_display_POS_port *p;
  struct genom_display_POS_ph *ph;

  p = &self->data->self->ports.POS;

  ph = genom_display_POS_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_display_POS_open ------------------------------------------- */

genom_event
genom_display_POS_open(
  genom_context self)
{
  struct genom_display_POS_port *p;
  struct genom_display_POS_ph *ph;
  char name[H2_DEV_MAX_NAME];
  int n;

  p = &self->data->self->ports.POS;

  n = snprintf(name, sizeof(name), "%s/POS", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port POS name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  genom_log_info("created inport %s", name);
  return genom_ok;
}


/* --- genom_display_POS_close ------------------------------------------ */

genom_event
genom_display_POS_close(
  genom_context self)
{
  struct genom_display_POS_port *p;
  struct genom_display_POS_ph *ph;

  p = &self->data->self->ports.POS;

  ph = genom_display_POS_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  genom_log_info("destroyed inport POS");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_display_POS_delete ----------------------------------------- */

void
genom_display_POS_delete(genom_context self)
{
  genom_display_POS_close(self);
}


/* --- genom_display_BAT_get_ph ----------------------------------------- */

static __inline__ struct genom_display_BAT_ph *
genom_display_BAT_get_ph(
  struct genom_display_BAT_port *p)
{
  return &p->h;
}


/* --- genom_display_BAT_data ------------------------------------------- */

loco_data *
genom_display_BAT_data(
  genom_context self)
{
  struct genom_display_BAT_port *p;
  struct genom_display_BAT_ph *ph;

  p = &self->data->self->ports.BAT;

  ph = genom_display_BAT_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_display_BAT_open ------------------------------------------- */

genom_event
genom_display_BAT_open(
  genom_context self)
{
  struct genom_display_BAT_port *p;
  struct genom_display_BAT_ph *ph;
  char name[H2_DEV_MAX_NAME];
  int n;

  p = &self->data->self->ports.BAT;

  n = snprintf(name, sizeof(name), "%s/BAT", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port BAT name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  genom_log_info("created inport %s", name);
  return genom_ok;
}


/* --- genom_display_BAT_close ------------------------------------------ */

genom_event
genom_display_BAT_close(
  genom_context self)
{
  struct genom_display_BAT_port *p;
  struct genom_display_BAT_ph *ph;

  p = &self->data->self->ports.BAT;

  ph = genom_display_BAT_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  genom_log_info("destroyed inport BAT");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_display_BAT_delete ----------------------------------------- */

void
genom_display_BAT_delete(genom_context self)
{
  genom_display_BAT_close(self);
}



/* --- genom_display_IM_connect ----------------------------------------- */

genom_event
genom_display_IM_connect(
  const char *name, genom_context self)
{
  struct genom_display_IM_port *p =
    &self->data->self->ports.IM;
  struct genom_display_IM_ph *ph;
  POSTER_ID pid;

  ph = genom_display_IM_get_ph(p);

  if (!ph) return genom_no_such_inport(self);

  if (posterFind(name, &pid) != OK) {
    genom_log_warn(1, "no such port %s", name);
    return genom_no_such_outport(self);
  }
  if (posterTake(pid, POSTER_READ) != OK) {
    genom_log_warn(1, "cannot connect port %s", name);
    return genom_port_io(self);
  }
  posterGive(pid);

  ph->id = pid;
  return genom_ok;
}


/* --- genom_display_IM_read -------------------------------------------- */

genom_event
genom_display_IM_read(
  genom_context self)
{
  struct genom_display_IM_port *p;
  struct genom_display_IM_ph *ph;
  STATUS s;
  char *b;
  ssize_t max;

  p = &self->data->self->ports.IM;

  ph = genom_display_IM_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_inport(self);

  s = posterTake(ph->id, POSTER_READ);
  if (s != OK) {
    genom_log_warn(1, "cannot access inport IM");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  max = -1;
  s = genom_deserialize_t_camera_map(
    &b, &max, &(ph->buffer));
  posterGive(ph->id);
  if (s) {
    genom_log_warn(0, "cannot read inport IM contents");
    return genom_serialization(self);
  }

  return genom_ok;
}


/* --- genom_display_AR_connect ----------------------------------------- */

genom_event
genom_display_AR_connect(
  const char *name, genom_context self)
{
  struct genom_display_AR_port *p =
    &self->data->self->ports.AR;
  struct genom_display_AR_ph *ph;
  POSTER_ID pid;

  ph = genom_display_AR_get_ph(p);

  if (!ph) return genom_no_such_inport(self);

  if (posterFind(name, &pid) != OK) {
    genom_log_warn(1, "no such port %s", name);
    return genom_no_such_outport(self);
  }
  if (posterTake(pid, POSTER_READ) != OK) {
    genom_log_warn(1, "cannot connect port %s", name);
    return genom_port_io(self);
  }
  posterGive(pid);

  ph->id = pid;
  return genom_ok;
}


/* --- genom_display_AR_read -------------------------------------------- */

genom_event
genom_display_AR_read(
  genom_context self)
{
  struct genom_display_AR_port *p;
  struct genom_display_AR_ph *ph;
  STATUS s;
  char *b;
  ssize_t max;

  p = &self->data->self->ports.AR;

  ph = genom_display_AR_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_inport(self);

  s = posterTake(ph->id, POSTER_READ);
  if (s != OK) {
    genom_log_warn(1, "cannot access inport AR");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  max = -1;
  s = genom_deserialize_t_camera_arena(
    &b, &max, &(ph->buffer));
  posterGive(ph->id);
  if (s) {
    genom_log_warn(0, "cannot read inport AR contents");
    return genom_serialization(self);
  }

  return genom_ok;
}


/* --- genom_display_POS_connect ---------------------------------------- */

genom_event
genom_display_POS_connect(
  const char *name, genom_context self)
{
  struct genom_display_POS_port *p =
    &self->data->self->ports.POS;
  struct genom_display_POS_ph *ph;
  POSTER_ID pid;

  ph = genom_display_POS_get_ph(p);

  if (!ph) return genom_no_such_inport(self);

  if (posterFind(name, &pid) != OK) {
    genom_log_warn(1, "no such port %s", name);
    return genom_no_such_outport(self);
  }
  if (posterTake(pid, POSTER_READ) != OK) {
    genom_log_warn(1, "cannot connect port %s", name);
    return genom_port_io(self);
  }
  posterGive(pid);

  ph->id = pid;
  return genom_ok;
}


/* --- genom_display_POS_read ------------------------------------------- */

genom_event
genom_display_POS_read(
  genom_context self)
{
  struct genom_display_POS_port *p;
  struct genom_display_POS_ph *ph;
  STATUS s;
  char *b;
  ssize_t max;

  p = &self->data->self->ports.POS;

  ph = genom_display_POS_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_inport(self);

  s = posterTake(ph->id, POSTER_READ);
  if (s != OK) {
    genom_log_warn(1, "cannot access inport POS");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  max = -1;
  s = genom_deserialize_t_camera_robot(
    &b, &max, &(ph->buffer));
  posterGive(ph->id);
  if (s) {
    genom_log_warn(0, "cannot read inport POS contents");
    return genom_serialization(self);
  }

  return genom_ok;
}


/* --- genom_display_BAT_connect ---------------------------------------- */

genom_event
genom_display_BAT_connect(
  const char *name, genom_context self)
{
  struct genom_display_BAT_port *p =
    &self->data->self->ports.BAT;
  struct genom_display_BAT_ph *ph;
  POSTER_ID pid;

  ph = genom_display_BAT_get_ph(p);

  if (!ph) return genom_no_such_inport(self);

  if (posterFind(name, &pid) != OK) {
    genom_log_warn(1, "no such port %s", name);
    return genom_no_such_outport(self);
  }
  if (posterTake(pid, POSTER_READ) != OK) {
    genom_log_warn(1, "cannot connect port %s", name);
    return genom_port_io(self);
  }
  posterGive(pid);

  ph->id = pid;
  return genom_ok;
}


/* --- genom_display_BAT_read ------------------------------------------- */

genom_event
genom_display_BAT_read(
  genom_context self)
{
  struct genom_display_BAT_port *p;
  struct genom_display_BAT_ph *ph;
  STATUS s;
  char *b;
  ssize_t max;

  p = &self->data->self->ports.BAT;

  ph = genom_display_BAT_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_inport(self);

  s = posterTake(ph->id, POSTER_READ);
  if (s != OK) {
    genom_log_warn(1, "cannot access inport BAT");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  max = -1;
  s = genom_deserialize_t_loco_data(
    &b, &max, &(ph->buffer));
  posterGive(ph->id);
  if (s) {
    genom_log_warn(0, "cannot read inport BAT contents");
    return genom_serialization(self);
  }

  return genom_ok;
}



/* --- genom_display_genom_state_write ---------------------------------- */

genom_event
genom_display_genom_state_write(
  genom_context self)
{
  static struct genom_display_genom_state_port *p;
  struct genom_display_genom_state_ph *ph;
  STATUS s;
  char *b;
  size_t l;

  p = &self->data->self->ports.genom_state;

  ph = genom_display_genom_state_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_outport(self);

  l = genom_serialen_t_genom_state_component(
    &(ph->buffer));
  if (l > ph->size || l + (1<<17) < ph->size) {
    s = posterIoctl(ph->id, FIO_RESIZE, &l);
    if (s != OK) {
      genom_log_warn(1, "cannot resize outport genom_state to %zu bytes", l);
      return genom_serialization(self);
    }
    ph->size = l;
  }

  s = posterTake(ph->id, POSTER_WRITE);
  if (s != OK) {
    genom_log_warn(1, "cannot access outport genom_state");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  genom_serialize_t_genom_state_component(
    &b, &(ph->buffer));
  s = posterGive(ph->id);
  if (s != OK) {
    genom_log_warn(1, "cannot flush outport genom_state");
    return genom_port_io(self);
  }

  return genom_ok;
}


/* --- genom_display_genom_metadata_write ------------------------------- */

genom_event
genom_display_genom_metadata_write(
  genom_context self)
{
  static struct genom_display_genom_metadata_port *p;
  struct genom_display_genom_metadata_ph *ph;
  STATUS s;
  char *b;
  size_t l;

  p = &self->data->self->ports.genom_metadata;

  ph = genom_display_genom_metadata_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_outport(self);

  l = genom_serialen_t_pocolibs_metadata_component(
    &(ph->buffer));
  if (l > ph->size || l + (1<<17) < ph->size) {
    s = posterIoctl(ph->id, FIO_RESIZE, &l);
    if (s != OK) {
      genom_log_warn(1, "cannot resize outport genom_metadata to %zu bytes", l);
      return genom_serialization(self);
    }
    ph->size = l;
  }

  s = posterTake(ph->id, POSTER_WRITE);
  if (s != OK) {
    genom_log_warn(1, "cannot access outport genom_metadata");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  genom_serialize_t_pocolibs_metadata_component(
    &b, &(ph->buffer));
  s = posterGive(ph->id);
  if (s != OK) {
    genom_log_warn(1, "cannot flush outport genom_metadata");
    return genom_port_io(self);
  }

  return genom_ok;
}


/* --- genom_display_JS_write ------------------------------------------- */

genom_event
genom_display_JS_write(
  genom_context self)
{
  static struct genom_display_JS_port *p;
  struct genom_display_JS_ph *ph;
  STATUS s;
  char *b;
  size_t l;

  p = &self->data->self->ports.JS;

  ph = genom_display_JS_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_outport(self);

  l = genom_serialen_t_display_order(
    &(ph->buffer));
  if (l > ph->size || l + (1<<17) < ph->size) {
    s = posterIoctl(ph->id, FIO_RESIZE, &l);
    if (s != OK) {
      genom_log_warn(1, "cannot resize outport JS to %zu bytes", l);
      return genom_serialization(self);
    }
    ph->size = l;
  }

  s = posterTake(ph->id, POSTER_WRITE);
  if (s != OK) {
    genom_log_warn(1, "cannot access outport JS");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  genom_serialize_t_display_order(
    &b, &(ph->buffer));
  s = posterGive(ph->id);
  if (s != OK) {
    genom_log_warn(1, "cannot flush outport JS");
    return genom_port_io(self);
  }

  return genom_ok;
}


/* --- end of file --------------------------------------------------------- */

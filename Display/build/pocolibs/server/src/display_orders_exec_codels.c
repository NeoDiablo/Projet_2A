/* --- Generated by genom 2.99.29. Do not edit -------------------------- */

#include "autoconf/acheader.h"

#include "commonStructLib.h"

#include "display_control_task.h"



/* --- task orders ------------------------------------------------------ */

/* state start */
static __inline__ genom_event
display_codel_task_orders_start(
  struct genom_component_data *self, struct genom_activity *activity)
{
  (void)activity; /* fix -Wunused-parameter */
  genom_event s;

  genom_take_resource(
    self,
    self->resources.all,

    self->resources.task_orders = InitOrdersParameters);
  s = InitOrdersParameters(&(self->ids.command), &self->tasks.orders.context);
  genom_give_resource(self, self->resources.task_orders = NULL);

  return s;
}

/* invoke codels according to orders state */
static __inline__ enum genom_activity_status
display_invoke_task_orders(
  struct genom_component_data *self, struct genom_activity *a)
{
  genom_event s;

  genom_log_debug(
    "task orders invoking task orders %s", a->state);

  if (a->state == display_start) {
    s = display_codel_task_orders_start(self, a);
    genom_log_debug("task orders yielded %s", s);
    if (
      0) {
      a->state = s;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = s;
      a->pause = 1;
      return ACT_RUN;
    }
    if (
      s == display_ether ||
      0) {
      a->state = display_ether;
      return ACT_ETHER;
    }
    goto ex;
  }

  /* default start, if not already handled above */
  if (a->state == display_start) {
    a->state = display_ether;
    return ACT_ETHER;
  }

  /* default stop, if not already handled above */
  if (a->state == display_stop) {
    genom_interrupted_detail d;

    assert(a->interruptedby);
    strncpy(d.by, a->interruptedby, sizeof(d.by));
    d.by[sizeof(d.by)-1] = *"";
    s = genom_interrupted(&d, &self->tasks.orders.context);
    goto ex;
  }

  /* this cannot happen by construction */
  genom_log_warn(0, "bad state (%s) in task_orders",
                 a->state?a->state : "genom_ok");
  abort();
  /*NOTREACHED*/

ex:
  if (
    s != genom_incompatible_digest_id &&
    s != genom_bad_transition_id &&
    s != genom_interrupted_id &&
    s != genom_serialization_id &&
    s != genom_too_many_activities_id &&
    s != genom_disallowed_id &&
    s != genom_mwerr_id &&
    1) {
    genom_bad_transition_detail d;
    strncpy(d.from, a->state, sizeof(d.from)); d.from[sizeof(d.from)-1] = *"";
    strncpy(d.to, s, sizeof(d.to)); d.to[sizeof(d.to)-1] = *"";
    genom_log_warn(
      0, "bad transition from %s to %s in task orders",
      a->state, s?s:"genom_ok");
    genom_bad_transition(&d, &self->tasks.orders.context);
  }

  a->state = NULL;
  return ACT_ETHER;
}


/* --- service SendOrders ----------------------------------------------- */

/* state start */
static __inline__ genom_event
display_codel_service_SendOrders_start(
  struct genom_component_data *self, struct genom_activity *activity)
{
  (void)activity; /* fix -Wunused-parameter */
  genom_event s;

  genom_take_resource(
    self,
    self->resources.all,

    self->resources.task_orders = GetChar);
  s = GetChar(&(self->ids.command), &(self->ids.key), &self->tasks.orders.context);
  genom_give_resource(self, self->resources.task_orders = NULL);

  return s;
}

/* state trad */
static __inline__ genom_event
display_codel_service_SendOrders_trad(
  struct genom_component_data *self, struct genom_activity *activity)
{
  (void)activity; /* fix -Wunused-parameter */
  genom_event s;

  genom_take_resource(
    self,
    self->resources.all,

    self->resources.task_orders = TradAndSendOrder);
  s = TradAndSendOrder(self->ids.key, &(self->ids.command), &(self->ports.JS.handle), &self->tasks.orders.context);
  genom_give_resource(self, self->resources.task_orders = NULL);

  return s;
}

/* invoke codels according to SendOrders state */
static __inline__ enum genom_activity_status
display_invoke_service_SendOrders(
  struct genom_component_data *self, struct genom_activity *a)
{
  genom_event s;

  genom_log_debug(
    "task orders invoking service SendOrders %s", a->state);

  if (a->state == display_start) {
    s = display_codel_service_SendOrders_start(self, a);
    genom_log_debug("service SendOrders yielded %s", s);
    if (
      s == display_trad ||
      0) {
      a->state = s;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = s;
      a->pause = 1;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = display_ether;
      return ACT_ETHER;
    }
    goto ex;
  }

  if (a->state == display_trad) {
    s = display_codel_service_SendOrders_trad(self, a);
    genom_log_debug("service SendOrders yielded %s", s);
    if (
      s == display_start ||
      0) {
      a->state = s;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = s;
      a->pause = 1;
      return ACT_RUN;
    }
    if (
      s == display_ether ||
      0) {
      a->state = display_ether;
      return ACT_ETHER;
    }
    goto ex;
  }


  /* default stop, if not already handled above */
  if (a->state == display_stop) {
    genom_interrupted_detail d;

    assert(a->interruptedby);
    strncpy(d.by, a->interruptedby, sizeof(d.by));
    d.by[sizeof(d.by)-1] = *"";
    s = genom_interrupted(&d, &self->tasks.orders.context);
    goto ex;
  }

  /* this cannot happen by construction */
  genom_log_warn(0, "bad state (%s) in service_SendOrders",
                 a->state?a->state : "genom_ok");
  abort();
  /*NOTREACHED*/

ex:
  if (
    s != genom_incompatible_digest_id &&
    s != genom_bad_transition_id &&
    s != genom_interrupted_id &&
    s != genom_serialization_id &&
    s != genom_too_many_activities_id &&
    s != genom_disallowed_id &&
    s != genom_mwerr_id &&
    s != display_INVALID_ORDER_id &&
    1) {
    genom_bad_transition_detail d;
    strncpy(d.from, a->state, sizeof(d.from)); d.from[sizeof(d.from)-1] = *"";
    strncpy(d.to, s, sizeof(d.to)); d.to[sizeof(d.to)-1] = *"";
    genom_log_warn(
      0, "bad transition from %s to %s in service SendOrders",
      a->state, s?s:"genom_ok");
    genom_bad_transition(&d, &self->tasks.orders.context);
  }

  a->state = NULL;
  return ACT_ETHER;
}



/* === task orders ====================================================== */

enum genom_activity_status
genom_display_orders_invoke(
  struct genom_component_data *self, struct genom_activity *a)
{
  switch(a->sid) {
    case -1:
      return display_invoke_task_orders(self, a);

    case DISPLAY_SendOrders_RQSTID:
      return display_invoke_service_SendOrders(self, a);
  }

  /* must not happen */
  genom_log_warn(0, "bad activity %d in task orders", a->sid);
  abort();
  return ACT_VOID;
}

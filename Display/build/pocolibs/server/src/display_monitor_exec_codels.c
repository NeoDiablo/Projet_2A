/* --- Generated by genom 2.99.29. Do not edit -------------------------- */

#include "autoconf/acheader.h"

#include "commonStructLib.h"

#include "display_control_task.h"



/* --- task monitor ----------------------------------------------------- */

/* state start */
static __inline__ genom_event
display_codel_task_monitor_start(
  struct genom_component_data *self, struct genom_activity *activity)
{
  (void)activity; /* fix -Wunused-parameter */
  genom_event s;

  genom_take_resource(
    self,
    self->resources.control == genom_display_GetCurrentPosition_controlcb ||
    self->resources.control == genom_display_GetCurrentBattery_controlcb ||
    self->resources.control == genom_display_GetCurrentMap_controlcb ||
    self->resources.control == genom_display_GetCurrentArena_controlcb ||
    self->resources.all,

    self->resources.task_monitor = InitMonitorParameters);
  s = InitMonitorParameters(&(self->ids.image), &(self->ids.arene), &(self->ids.position), &(self->ids.batterie), &self->tasks.monitor.context);
  genom_give_resource(self, self->resources.task_monitor = NULL);

  return s;
}

/* invoke codels according to monitor state */
static __inline__ enum genom_activity_status
display_invoke_task_monitor(
  struct genom_component_data *self, struct genom_activity *a)
{
  genom_event s;

  genom_log_debug(
    "task monitor invoking task monitor %s", a->state);

  if (a->state == display_start) {
    s = display_codel_task_monitor_start(self, a);
    genom_log_debug("task monitor yielded %s", s);
    if (
      0) {
      a->state = s;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = s;
      a->pause = 1;
      return ACT_RUN;
    }
    if (
      s == display_ether ||
      0) {
      a->state = display_ether;
      return ACT_ETHER;
    }
    goto ex;
  }

  /* default start, if not already handled above */
  if (a->state == display_start) {
    a->state = display_ether;
    return ACT_ETHER;
  }

  /* default stop, if not already handled above */
  if (a->state == display_stop) {
    genom_interrupted_detail d;

    assert(a->interruptedby);
    strncpy(d.by, a->interruptedby, sizeof(d.by));
    d.by[sizeof(d.by)-1] = *"";
    s = genom_interrupted(&d, &self->tasks.monitor.context);
    goto ex;
  }

  /* this cannot happen by construction */
  genom_log_warn(0, "bad state (%s) in task_monitor",
                 a->state?a->state : "genom_ok");
  abort();
  /*NOTREACHED*/

ex:
  if (
    s != genom_incompatible_digest_id &&
    s != genom_bad_transition_id &&
    s != genom_interrupted_id &&
    s != genom_serialization_id &&
    s != genom_too_many_activities_id &&
    s != genom_disallowed_id &&
    s != genom_mwerr_id &&
    1) {
    genom_bad_transition_detail d;
    strncpy(d.from, a->state, sizeof(d.from)); d.from[sizeof(d.from)-1] = *"";
    strncpy(d.to, s, sizeof(d.to)); d.to[sizeof(d.to)-1] = *"";
    genom_log_warn(
      0, "bad transition from %s to %s in task monitor",
      a->state, s?s:"genom_ok");
    genom_bad_transition(&d, &self->tasks.monitor.context);
  }

  a->state = NULL;
  return ACT_ETHER;
}


/* --- service Monitoring ----------------------------------------------- */

/* state start */
static __inline__ genom_event
display_codel_service_Monitoring_start(
  struct genom_component_data *self, struct genom_activity *activity)
{
  (void)activity; /* fix -Wunused-parameter */
  genom_event s;

  genom_take_resource(
    self,
    self->resources.control == genom_display_GetCurrentPosition_controlcb ||
    self->resources.control == genom_display_GetCurrentBattery_controlcb ||
    self->resources.control == genom_display_GetCurrentMap_controlcb ||
    self->resources.control == genom_display_GetCurrentArena_controlcb ||
    self->resources.all,

    self->resources.task_monitor = StartMonitoring);
  s = StartMonitoring(&(self->ports.IM.handle), &(self->ports.AR.handle), &(self->ports.POS.handle), &(self->ports.BAT.handle), &(self->ids.image), &(self->ids.arene), &(self->ids.position), &(self->ids.batterie), &self->tasks.monitor.context);
  genom_give_resource(self, self->resources.task_monitor = NULL);

  return s;
}

/* state show */
static __inline__ genom_event
display_codel_service_Monitoring_show(
  struct genom_component_data *self, struct genom_activity *activity)
{
  (void)activity; /* fix -Wunused-parameter */
  genom_event s;

  genom_take_resource(
    self,
    self->resources.all,

    self->resources.task_monitor = ShowMonitoring);
  s = ShowMonitoring(&(self->ids.image), &(self->ids.arene), &(self->ids.position), &(self->ids.batterie), &self->tasks.monitor.context);
  genom_give_resource(self, self->resources.task_monitor = NULL);

  return s;
}

/* invoke codels according to Monitoring state */
static __inline__ enum genom_activity_status
display_invoke_service_Monitoring(
  struct genom_component_data *self, struct genom_activity *a)
{
  genom_event s;

  genom_log_debug(
    "task monitor invoking service Monitoring %s", a->state);

  if (a->state == display_start) {
    s = display_codel_service_Monitoring_start(self, a);
    genom_log_debug("service Monitoring yielded %s", s);
    if (
      s == display_show ||
      0) {
      a->state = s;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = s;
      a->pause = 1;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = display_ether;
      return ACT_ETHER;
    }
    goto ex;
  }

  if (a->state == display_show) {
    s = display_codel_service_Monitoring_show(self, a);
    genom_log_debug("service Monitoring yielded %s", s);
    if (
      0) {
      a->state = s;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = s;
      a->pause = 1;
      return ACT_RUN;
    }
    if (
      s == display_ether ||
      0) {
      a->state = display_ether;
      return ACT_ETHER;
    }
    goto ex;
  }


  /* default stop, if not already handled above */
  if (a->state == display_stop) {
    genom_interrupted_detail d;

    assert(a->interruptedby);
    strncpy(d.by, a->interruptedby, sizeof(d.by));
    d.by[sizeof(d.by)-1] = *"";
    s = genom_interrupted(&d, &self->tasks.monitor.context);
    goto ex;
  }

  /* this cannot happen by construction */
  genom_log_warn(0, "bad state (%s) in service_Monitoring",
                 a->state?a->state : "genom_ok");
  abort();
  /*NOTREACHED*/

ex:
  if (
    s != genom_incompatible_digest_id &&
    s != genom_bad_transition_id &&
    s != genom_interrupted_id &&
    s != genom_serialization_id &&
    s != genom_too_many_activities_id &&
    s != genom_disallowed_id &&
    s != genom_mwerr_id &&
    s != display_INVALID_DATA_id &&
    1) {
    genom_bad_transition_detail d;
    strncpy(d.from, a->state, sizeof(d.from)); d.from[sizeof(d.from)-1] = *"";
    strncpy(d.to, s, sizeof(d.to)); d.to[sizeof(d.to)-1] = *"";
    genom_log_warn(
      0, "bad transition from %s to %s in service Monitoring",
      a->state, s?s:"genom_ok");
    genom_bad_transition(&d, &self->tasks.monitor.context);
  }

  a->state = NULL;
  return ACT_ETHER;
}



/* === task monitor ===================================================== */

enum genom_activity_status
genom_display_monitor_invoke(
  struct genom_component_data *self, struct genom_activity *a)
{
  switch(a->sid) {
    case -1:
      return display_invoke_task_monitor(self, a);

    case DISPLAY_Monitoring_RQSTID:
      return display_invoke_service_Monitoring(self, a);
  }

  /* must not happen */
  genom_log_warn(0, "bad activity %d in task monitor", a->sid);
  abort();
  return ACT_VOID;
}

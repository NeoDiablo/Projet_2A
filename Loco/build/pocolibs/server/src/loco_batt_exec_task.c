/* --- Generated by genom 2.99.29. Do not edit -------------------------- */

#include "autoconf/acheader.h"

#include <sys/time.h>

#include <stdio.h>

#include "commonStructLib.h"
#include "h2evnLib.h"
#include "h2timerLib.h"
#include "taskLib.h"

#include "loco_control_task.h"


/* --- local data ---------------------------------------------------------- */

/* maximum batt mbox size */
static __inline__ size_t
loco_batt_mbox_size(void)
{
  return 0;
}


/* --- genom_loco_batt_exec_task ---------------------------------------- */

void *
genom_loco_batt_exec_task(void *data)
{
  enum {
    GENOM_SCHED_DONE = 1,
    GENOM_SCHED_ONE = 2,
    GENOM_SCHED_CONT = 4,
    GENOM_SCHED_WAKE = 8
  };
  struct genom_component_data *self = data;
  genom_state_rusage *usage = &self->tasks.batt.rusage;
  struct genom_activity *a;
  struct timeval tvs, tve;
  H2TIMER_ID timer;
  enum genom_activity_status e;
  int sched;
  size_t id;

  /* create an h2 timer */
  timer = h2timerAlloc();
  if (timer == NULL) {
    genom_log_warn(1, "cannot create timer for %s exec task", "batt");
    goto signal_parent;
  }

  if (h2timerStart(timer, 2, 0) != OK) {
    genom_log_warn(1, "cannot start timer for %s exec task", "batt");
    goto signal_parent;
  }

  /* initialize csLib for remotes */
  if (loco_batt_mbox_size()) {
    char mbox[64];
    snprintf(mbox, sizeof(mbox), "%s/%s", genom_instance, "batt");

    if (csMboxInit(mbox, 0, loco_batt_mbox_size()) == ERROR) {
      genom_log_warn(1, "cannot create %s task mailbox %s",
                     "batt", mbox);
      goto signal_parent;
    }
  }

  /* run */
  genom_log_info("spawned task batt");
  sched = GENOM_SCHED_CONT;
  gettimeofday(&tvs, NULL);
  tve = tvs;

  do {
    /* wait for next event */
    if (!(sched & GENOM_SCHED_CONT)) {
      if (h2timerPause(timer) != OK) abort();
      gettimeofday(&tvs, NULL);
      genom_log_debug("batt tick");
    }
    pthread_mutex_lock(&self->tasks.batt.lock);
    /* paused activities are only awaken on a period tick */
    self->tasks.batt.runnable = !(sched & GENOM_SCHED_CONT);
    sched = 0;

    if (self->tasks.batt.shutdown) {
      pthread_mutex_unlock(&self->tasks.batt.lock);
      break;
    }

    /* handle start/stop requests, wake up paused activities */
    for(id = 0; id < genom_max_activities(); id++) {
      a = &self->tasks.batt.activities.a[id].any;
      switch(a->status) {
        case ACT_VOID: case ACT_ETHER: continue;

        case ACT_INIT:
          if (a->start && self->tasks.batt.runnable) {
            /* start request, only on a tick in periodic tasks */
            a->status = ACT_RUN;
            a->state = loco_start;
            a->start = 0;
            a->pause = 0;
          }
          if (a->stop) {
            /* stop before start: raise 'interrupted' exception, except for
             * the permanent activity for which we still go to stop */
            if (a == self->tasks.batt.permanent) {
              a->status = ACT_STOP;
              a->state = loco_stop;
              a->stop = 0;
              a->pause = 0;
            } else {
              genom_interrupted_detail d;
              assert(a->interruptedby);
              strncpy(d.by, a->interruptedby, sizeof(d.by));
              d.by[sizeof(d.by)-1] = *"";
              genom_interrupted(&d, &self->tasks.batt.context);

              a->status = ACT_ETHER;
              a->stop = 0;
              a->exdetail = (void *)self->tasks.batt.context.raised(
                &a->state, &self->tasks.batt.context);
              sched |= GENOM_SCHED_DONE;
            }
          }
          break;

        case ACT_RUN:
          if (a->stop) {
            a->status = ACT_STOP;
            a->state = loco_stop;
            a->stop = 0;
            a->pause = 0;
          }
          /*FALLTHROUGH*/
        case ACT_STOP:
          if (a->pause && self->tasks.batt.runnable) {
            a->pause = 0;
          }
          break;
      }
    }
    self->tasks.batt.runnable = 0;

    /* run activities */
    for(id = 0; id < genom_max_activities(); id++) {
      a = &self->tasks.batt.activities.a[id].any;
      if (a->status != ACT_RUN && a->status != ACT_STOP) continue;
      if (a->pause) continue;

      pthread_mutex_unlock(&self->tasks.batt.lock);
      e = genom_loco_batt_invoke(self, a);
      pthread_mutex_lock(&self->tasks.batt.lock);
      switch(e) {
        case ACT_RUN:
          if (!a->pause)
            sched |= GENOM_SCHED_CONT | GENOM_SCHED_WAKE;
          break;

        case ACT_ETHER:
          if (a->state == NULL /* exception raised */)
            a->exdetail = (void *)self->tasks.batt.context.raised(
              &a->state, &self->tasks.batt.context);
          a->status = ACT_ETHER;
          sched |= GENOM_SCHED_DONE | GENOM_SCHED_WAKE;
          break;

        case ACT_VOID: case ACT_INIT: case ACT_STOP:
          assert(!"not reached");
      }
      sched |= GENOM_SCHED_ONE;
    }

    if (sched & GENOM_SCHED_ONE)
      pthread_cond_broadcast(&self->tasks.batt.sync);
    if (sched & GENOM_SCHED_WAKE)
      self->tasks.batt.runnable = 1;
    pthread_mutex_unlock(&self->tasks.batt.lock);

    /* send signals */
    if (sched & GENOM_SCHED_DONE) {
      pthread_spin_lock(&self->control.rlock);
      self->control.rusage_update = tvs;
      pthread_spin_unlock(&self->control.rlock);
      genom_loco_schedule_cntrl(self);
    }
    if (sched & GENOM_SCHED_WAKE) {
      pthread_mutex_lock(&self->tasks.move.lock);
      if (!self->tasks.move.runnable) {
        self->tasks.move.runnable = 1;
        pthread_cond_broadcast(&self->tasks.move.sync);
      }
      pthread_mutex_unlock(&self->tasks.move.lock);
    }

    /* update rusage */
    if (sched & GENOM_SCHED_CONT) /* at each period only */ continue;
    {
      double last;
      double dt;
      genom_state_rusage u = *usage;
      struct timeval rup;

      gettimeofday(&tve, NULL);
      dt = 0.1;

      last = tve.tv_sec - tvs.tv_sec + (tve.tv_usec - tvs.tv_usec)*1e-6;
      if (sched & GENOM_SCHED_ONE) {
        u.cycles++;

        u.timings.last = last;
        u.load.last = 100. * last / dt;

        if (u.timings.max < u.timings.last) u.timings.max = u.timings.last;
        if (u.load.max < u.load.last) u.load.max = u.load.last;
      }

      if (dt > 10.) dt = 10.;
      u.timings.avg += (last - u.timings.avg) * dt / 10.;
      u.load.avg += (100. * last - dt * u.load.avg) / 10.;

      pthread_spin_lock(&self->tasks.batt.rlock);
      *usage = u;
      pthread_spin_unlock(&self->tasks.batt.rlock);

      /* wake up control task if needed (1s timeout) */
      pthread_spin_lock(&self->control.rlock);
      rup = self->control.rusage_update;
      dt = tve.tv_sec - rup.tv_sec + (tve.tv_usec - rup.tv_usec)*1e-6;
      if (dt > 1.) {
        self->control.rusage_update = tve;
        pthread_spin_unlock(&self->control.rlock);
        genom_loco_schedule_cntrl(self);
      } else
        pthread_spin_unlock(&self->control.rlock);
    }
  } while(1);

  genom_log_info("shutting down %s exec task", "batt");

  if (loco_batt_mbox_size()) {
    csMboxEnd();
  }
  h2timerStop(timer);
  h2timerFree(timer);

signal_parent:
  pthread_mutex_lock(&self->tasks.batt.lock);
  self->tasks.batt.taskid = ERROR;
  pthread_cond_broadcast(&self->tasks.batt.sync);
  pthread_mutex_unlock(&self->tasks.batt.lock);
  return NULL;
}

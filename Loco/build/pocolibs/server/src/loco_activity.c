/* --- Generated by genom 2.99.29. Do not edit -------------------------- */

#include "autoconf/acheader.h"

#include "loco_control_task.h"
#include "loco_activity.h"


/* --- genom_loco_activity_alloc ---------------------------------------- */

int
genom_loco_activity_alloc(struct genom_activities *activities)
{
  static int aid = 0;
  size_t id;

  /* look for the first free activity */
  for(id = 0; id < genom_max_activities(); id++) {
    if (activities->a[id].any.status == ACT_VOID) {
      activities->a[id].any.aid = ++aid;
      activities->a[id].any.status = ACT_INIT;
      activities->a[id].any.start = 0;
      activities->a[id].any.stop = 0;
      activities->a[id].any.pause = 0;
      return id;
    }
  }

  return -1;
}


/* === Send final replies ================================================== */

/* abort_activity */
static __inline__ void
genom_loco_abort_activity_activity_report(
  struct genom_component_data *self,
  struct genom_loco_abort_activity_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == loco_ether) {
    /* success: update after/before array */
    self->control.run_map[LOCO_abort_activity_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_loco_abort_activity_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_loco_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "abort_activity");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_loco_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "abort_activity");
    } else
      genom_log_warn(0, "invalid output for service %s", "abort_activity");
  }

  /* cleanup */
  genom_tfini_loco_abort_activity_activity(a);
}

/* connect_port */
static __inline__ void
genom_loco_connect_port_activity_report(
  struct genom_component_data *self,
  struct genom_loco_connect_port_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == loco_ether) {
    /* success: update after/before array */
    self->control.run_map[LOCO_connect_port_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_loco_connect_port_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_loco_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "connect_port");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_loco_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "connect_port");
    } else
      genom_log_warn(0, "invalid output for service %s", "connect_port");
  }

  /* cleanup */
  genom_tfini_loco_connect_port_activity(a);
}

/* connect_service */
static __inline__ void
genom_loco_connect_service_activity_report(
  struct genom_component_data *self,
  struct genom_loco_connect_service_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == loco_ether) {
    /* success: update after/before array */
    self->control.run_map[LOCO_connect_service_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_loco_connect_service_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_loco_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "connect_service");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_loco_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "connect_service");
    } else
      genom_log_warn(0, "invalid output for service %s", "connect_service");
  }

  /* cleanup */
  genom_tfini_loco_connect_service_activity(a);
}

/* kill */
static __inline__ void
genom_loco_kill_activity_report(
  struct genom_component_data *self,
  struct genom_loco_kill_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == loco_ether) {
    /* success: update after/before array */
    self->control.run_map[LOCO_kill_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_loco_kill_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_loco_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "kill");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_loco_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "kill");
    } else
      genom_log_warn(0, "invalid output for service %s", "kill");
  }

  /* cleanup */
  genom_tfini_loco_kill_activity(a);
}

/* GetCurrentPosition */
static __inline__ void
genom_loco_GetCurrentPosition_activity_report(
  struct genom_component_data *self,
  struct genom_loco_GetCurrentPosition_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == loco_ether) {
    /* success: update after/before array */
    self->control.run_map[LOCO_GetCurrentPosition_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_loco_GetCurrentPosition_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_loco_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "GetCurrentPosition");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_loco_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "GetCurrentPosition");
    } else
      genom_log_warn(0, "invalid output for service %s", "GetCurrentPosition");
  }

  /* cleanup */
  genom_tfini_loco_GetCurrentPosition_activity(a);
}

/* GetCurrentBattery */
static __inline__ void
genom_loco_GetCurrentBattery_activity_report(
  struct genom_component_data *self,
  struct genom_loco_GetCurrentBattery_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == loco_ether) {
    /* success: update after/before array */
    self->control.run_map[LOCO_GetCurrentBattery_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_loco_GetCurrentBattery_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_loco_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "GetCurrentBattery");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_loco_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "GetCurrentBattery");
    } else
      genom_log_warn(0, "invalid output for service %s", "GetCurrentBattery");
  }

  /* cleanup */
  genom_tfini_loco_GetCurrentBattery_activity(a);
}

/* GetCurrentMap */
static __inline__ void
genom_loco_GetCurrentMap_activity_report(
  struct genom_component_data *self,
  struct genom_loco_GetCurrentMap_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == loco_ether) {
    /* success: update after/before array */
    self->control.run_map[LOCO_GetCurrentMap_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_loco_GetCurrentMap_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_loco_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "GetCurrentMap");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_loco_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "GetCurrentMap");
    } else
      genom_log_warn(0, "invalid output for service %s", "GetCurrentMap");
  }

  /* cleanup */
  genom_tfini_loco_GetCurrentMap_activity(a);
}

/* GetCurrentArena */
static __inline__ void
genom_loco_GetCurrentArena_activity_report(
  struct genom_component_data *self,
  struct genom_loco_GetCurrentArena_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == loco_ether) {
    /* success: update after/before array */
    self->control.run_map[LOCO_GetCurrentArena_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_loco_GetCurrentArena_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_loco_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "GetCurrentArena");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_loco_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "GetCurrentArena");
    } else
      genom_log_warn(0, "invalid output for service %s", "GetCurrentArena");
  }

  /* cleanup */
  genom_tfini_loco_GetCurrentArena_activity(a);
}

/* MoveStop */
static __inline__ void
genom_loco_MoveStop_activity_report(
  struct genom_component_data *self,
  struct genom_loco_MoveStop_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == loco_ether) {
    /* success: update after/before array */
    self->control.run_map[LOCO_MoveStop_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_loco_MoveStop_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_loco_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "MoveStop");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_loco_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "MoveStop");
    } else
      genom_log_warn(0, "invalid output for service %s", "MoveStop");
  }

  /* cleanup */
  genom_tfini_loco_MoveStop_activity(a);
}

/* BattStop */
static __inline__ void
genom_loco_BattStop_activity_report(
  struct genom_component_data *self,
  struct genom_loco_BattStop_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == loco_ether) {
    /* success: update after/before array */
    self->control.run_map[LOCO_BattStop_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_loco_BattStop_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_loco_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "BattStop");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_loco_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "BattStop");
    } else
      genom_log_warn(0, "invalid output for service %s", "BattStop");
  }

  /* cleanup */
  genom_tfini_loco_BattStop_activity(a);
}

/* StartMove */
static __inline__ void
genom_loco_StartMove_activity_report(
  struct genom_component_data *self,
  struct genom_loco_StartMove_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == loco_ether) {
    /* success: update after/before array */
    self->control.run_map[LOCO_StartMove_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_loco_StartMove_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_loco_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "StartMove");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_loco_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "StartMove");
    } else
      genom_log_warn(0, "invalid output for service %s", "StartMove");
  }

  /* cleanup */
  genom_tfini_loco_StartMove_activity(a);
}

/* StartBatt */
static __inline__ void
genom_loco_StartBatt_activity_report(
  struct genom_component_data *self,
  struct genom_loco_StartBatt_activity *a)
{
  STATUS s;

  /* send final reply */
  if (a->h.state == loco_ether) {
    /* success: update after/before array */
    self->control.run_map[LOCO_StartBatt_RQSTID] = 1;

    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, OK,
      (char *)&a->out, 0, genom_loco_StartBatt_encode);
  } else
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, (char *)&a->h, 0,
      genom_loco_activity_encodex);
  if (s == ERROR) {
    genom_log_warn(1, "could not send output for service %s", "StartBatt");
    s = csServReplySend(
      self->control.csserv, a->h.rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_loco_genom_serialization_encodex);
    if (s == ERROR) {
      genom_log_warn(1, "discarding output for service %s", "StartBatt");
    } else
      genom_log_warn(0, "invalid output for service %s", "StartBatt");
  }

  /* cleanup */
  genom_tfini_loco_StartBatt_activity(a);
}


/* --- genom_loco_activity_report --------------------------------------- */

void
genom_loco_activity_report(
  struct genom_component_data *self, struct genom_activity *a)
{
  switch(a->sid) {
    case -1: return; /* permanent activity reports nothing */

    case LOCO_abort_activity_RQSTID:
      genom_loco_abort_activity_activity_report(
        self, (struct genom_loco_abort_activity_activity *)a);
      return;
    case LOCO_connect_port_RQSTID:
      genom_loco_connect_port_activity_report(
        self, (struct genom_loco_connect_port_activity *)a);
      return;
    case LOCO_connect_service_RQSTID:
      genom_loco_connect_service_activity_report(
        self, (struct genom_loco_connect_service_activity *)a);
      return;
    case LOCO_kill_RQSTID:
      genom_loco_kill_activity_report(
        self, (struct genom_loco_kill_activity *)a);
      return;
    case LOCO_GetCurrentPosition_RQSTID:
      genom_loco_GetCurrentPosition_activity_report(
        self, (struct genom_loco_GetCurrentPosition_activity *)a);
      return;
    case LOCO_GetCurrentBattery_RQSTID:
      genom_loco_GetCurrentBattery_activity_report(
        self, (struct genom_loco_GetCurrentBattery_activity *)a);
      return;
    case LOCO_GetCurrentMap_RQSTID:
      genom_loco_GetCurrentMap_activity_report(
        self, (struct genom_loco_GetCurrentMap_activity *)a);
      return;
    case LOCO_GetCurrentArena_RQSTID:
      genom_loco_GetCurrentArena_activity_report(
        self, (struct genom_loco_GetCurrentArena_activity *)a);
      return;
    case LOCO_MoveStop_RQSTID:
      genom_loco_MoveStop_activity_report(
        self, (struct genom_loco_MoveStop_activity *)a);
      return;
    case LOCO_BattStop_RQSTID:
      genom_loco_BattStop_activity_report(
        self, (struct genom_loco_BattStop_activity *)a);
      return;
    case LOCO_StartMove_RQSTID:
      genom_loco_StartMove_activity_report(
        self, (struct genom_loco_StartMove_activity *)a);
      return;
    case LOCO_StartBatt_RQSTID:
      genom_loco_StartBatt_activity_report(
        self, (struct genom_loco_StartBatt_activity *)a);
      return;
  }

  assert(!"code not reached");
}


/* --- genom_loco_activity_encodex ------------------------------------ */

int
genom_loco_activity_encodex(char *buffer, int size, char *dst, int maxsize)
{
  struct genom_activity *a = (struct genom_activity *)buffer;

  if (a->state == genom_unkex_id)
    return genom_loco_genom_unkex_encodex(a->exdetail, size, dst, maxsize);
  else if (a->state == genom_syserr_id)
    return genom_loco_genom_syserr_encodex(a->exdetail, size, dst, maxsize);
  else if (a->state == genom_incompatible_digest_id)
    return genom_loco_genom_incompatible_digest_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_bad_transition_id)
    return genom_loco_genom_bad_transition_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_interrupted_id)
    return genom_loco_genom_interrupted_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_serialization_id)
    return genom_loco_genom_serialization_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_too_many_activities_id)
    return genom_loco_genom_too_many_activities_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_disallowed_id)
    return genom_loco_genom_disallowed_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_mwerr_id)
    return genom_loco_genom_mwerr_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_no_such_activity_id)
    return genom_loco_genom_no_such_activity_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_no_such_inport_id)
    return genom_loco_genom_no_such_inport_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_no_such_outport_id)
    return genom_loco_genom_no_such_outport_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_port_io_id)
    return genom_loco_genom_port_io_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_no_such_remote_id)
    return genom_loco_genom_no_such_remote_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_no_such_service_id)
    return genom_loco_genom_no_such_service_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == genom_remote_io_id)
    return genom_loco_genom_remote_io_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == loco_INVALID_ORDER_id)
    return genom_loco_loco_INVALID_ORDER_encodex(
      a->exdetail, size, dst, maxsize);
  else if (a->state == loco_INVALID_DATA_id)
    return genom_loco_loco_INVALID_DATA_encodex(
      a->exdetail, size, dst, maxsize);

  assert(!"unknown genom exception");
  return 0;
}


/* === Interrupt incompatible activities =================================== */

/* abort_activity */
static __inline__ int
genom_loco_abort_activity_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}

/* connect_port */
static __inline__ int
genom_loco_connect_port_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}

/* connect_service */
static __inline__ int
genom_loco_connect_service_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}

/* kill */
static __inline__ int
genom_loco_kill_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  /* task move */
  pthread_mutex_lock(&self->tasks.move.lock);
  {
    struct genom_activity *c;
    size_t id;

    for(id = 0; id < genom_max_activities(); id++) {
      c = &self->tasks.move.activities.a[id].any;
      if (c->status == ACT_VOID || c->status == ACT_ETHER) continue;
      if (c->aid == a->aid) continue;
      switch(c->sid) {
        case LOCO_StartMove_RQSTID:
          switch(c->status) {
            case ACT_RUN:
              delay = 1;
              if (!self->tasks.move.runnable) {
                self->tasks.move.runnable = 1;
                pthread_cond_broadcast(&self->tasks.move.sync);
              }
              /*FALLTHROUGH*/
            case ACT_INIT:
              c->stop = 1;
              c->interruptedby = "kill";
              break;

            case ACT_STOP: delay = 1; break;

            default: assert(!"code not reached");
          }
      }
    }
  }
  pthread_mutex_unlock(&self->tasks.move.lock);

  /* task batt */
  pthread_mutex_lock(&self->tasks.batt.lock);
  {
    struct genom_activity *c;
    size_t id;

    for(id = 0; id < genom_max_activities(); id++) {
      c = &self->tasks.batt.activities.a[id].any;
      if (c->status == ACT_VOID || c->status == ACT_ETHER) continue;
      if (c->aid == a->aid) continue;
      switch(c->sid) {
        case LOCO_StartBatt_RQSTID:
          switch(c->status) {
            case ACT_RUN:
              delay = 1;
              if (!self->tasks.batt.runnable) {
                self->tasks.batt.runnable = 1;
                pthread_cond_broadcast(&self->tasks.batt.sync);
              }
              /*FALLTHROUGH*/
            case ACT_INIT:
              c->stop = 1;
              c->interruptedby = "kill";
              break;

            case ACT_STOP: delay = 1; break;

            default: assert(!"code not reached");
          }
      }
    }
  }
  pthread_mutex_unlock(&self->tasks.batt.lock);

  return delay;
}

/* GetCurrentPosition */
static __inline__ int
genom_loco_GetCurrentPosition_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}

/* GetCurrentBattery */
static __inline__ int
genom_loco_GetCurrentBattery_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}

/* GetCurrentMap */
static __inline__ int
genom_loco_GetCurrentMap_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}

/* GetCurrentArena */
static __inline__ int
genom_loco_GetCurrentArena_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}

/* MoveStop */
static __inline__ int
genom_loco_MoveStop_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  /* task move */
  pthread_mutex_lock(&self->tasks.move.lock);
  {
    struct genom_activity *c;
    size_t id;

    for(id = 0; id < genom_max_activities(); id++) {
      c = &self->tasks.move.activities.a[id].any;
      if (c->status == ACT_VOID || c->status == ACT_ETHER) continue;
      if (c->aid == a->aid) continue;
      switch(c->sid) {
        case LOCO_StartMove_RQSTID:
          switch(c->status) {
            case ACT_RUN:
              delay = 1;
              if (!self->tasks.move.runnable) {
                self->tasks.move.runnable = 1;
                pthread_cond_broadcast(&self->tasks.move.sync);
              }
              /*FALLTHROUGH*/
            case ACT_INIT:
              c->stop = 1;
              c->interruptedby = "MoveStop";
              break;

            case ACT_STOP: delay = 1; break;

            default: assert(!"code not reached");
          }
      }
    }
  }
  pthread_mutex_unlock(&self->tasks.move.lock);

  return delay;
}

/* BattStop */
static __inline__ int
genom_loco_BattStop_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  /* task batt */
  pthread_mutex_lock(&self->tasks.batt.lock);
  {
    struct genom_activity *c;
    size_t id;

    for(id = 0; id < genom_max_activities(); id++) {
      c = &self->tasks.batt.activities.a[id].any;
      if (c->status == ACT_VOID || c->status == ACT_ETHER) continue;
      if (c->aid == a->aid) continue;
      switch(c->sid) {
        case LOCO_StartBatt_RQSTID:
          switch(c->status) {
            case ACT_RUN:
              delay = 1;
              if (!self->tasks.batt.runnable) {
                self->tasks.batt.runnable = 1;
                pthread_cond_broadcast(&self->tasks.batt.sync);
              }
              /*FALLTHROUGH*/
            case ACT_INIT:
              c->stop = 1;
              c->interruptedby = "BattStop";
              break;

            case ACT_STOP: delay = 1; break;

            default: assert(!"code not reached");
          }
      }
    }
  }
  pthread_mutex_unlock(&self->tasks.batt.lock);

  return delay;
}

/* StartMove */
static __inline__ int
genom_loco_StartMove_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}

/* StartBatt */
static __inline__ int
genom_loco_StartBatt_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  int delay = 0;
  (void)self; (void)a; /* fix -Wunused-parameter */


  return delay;
}


/* --- genom_loco_interrupt_reqd ---------------------------------------- */

int
genom_loco_interrupt_reqd(
  struct genom_component_data *self, struct genom_activity *a)
{
  /* interrupt incompatible activities */
  switch(a->sid) {
    case -1: return 0; /* permanent activity is not interruptible */

    case LOCO_abort_activity_RQSTID:
      return genom_loco_abort_activity_interrupt_reqd(self, a);
    case LOCO_connect_port_RQSTID:
      return genom_loco_connect_port_interrupt_reqd(self, a);
    case LOCO_connect_service_RQSTID:
      return genom_loco_connect_service_interrupt_reqd(self, a);
    case LOCO_kill_RQSTID:
      return genom_loco_kill_interrupt_reqd(self, a);
    case LOCO_GetCurrentPosition_RQSTID:
      return genom_loco_GetCurrentPosition_interrupt_reqd(self, a);
    case LOCO_GetCurrentBattery_RQSTID:
      return genom_loco_GetCurrentBattery_interrupt_reqd(self, a);
    case LOCO_GetCurrentMap_RQSTID:
      return genom_loco_GetCurrentMap_interrupt_reqd(self, a);
    case LOCO_GetCurrentArena_RQSTID:
      return genom_loco_GetCurrentArena_interrupt_reqd(self, a);
    case LOCO_MoveStop_RQSTID:
      return genom_loco_MoveStop_interrupt_reqd(self, a);
    case LOCO_BattStop_RQSTID:
      return genom_loco_BattStop_interrupt_reqd(self, a);
    case LOCO_StartMove_RQSTID:
      return genom_loco_StartMove_interrupt_reqd(self, a);
    case LOCO_StartBatt_RQSTID:
      return genom_loco_StartBatt_interrupt_reqd(self, a);
  }

  assert(!"code not reached");
  return 0;
}

/* --- Generated by genom 2.99.29. Do not edit -------------------------- */

#include "autoconf/acheader.h"

#include "commonStructLib.h"

#include "loco_control_task.h"



/* --- task move -------------------------------------------------------- */

/* state start */
static __inline__ genom_event
loco_codel_task_move_start(
  struct genom_component_data *self, struct genom_activity *activity)
{
  (void)activity; /* fix -Wunused-parameter */
  genom_event s;

  genom_take_resource(
    self,
    self->resources.all,

    self->resources.task_move = InitMoveParameters);
  s = InitMoveParameters(&(self->ids.moteur), &self->tasks.move.context);
  genom_give_resource(self, self->resources.task_move = NULL);

  return s;
}

/* invoke codels according to move state */
static __inline__ enum genom_activity_status
loco_invoke_task_move(
  struct genom_component_data *self, struct genom_activity *a)
{
  genom_event s;

  genom_log_debug(
    "task move invoking task move %s", a->state);

  if (a->state == loco_start) {
    s = loco_codel_task_move_start(self, a);
    genom_log_debug("task move yielded %s", s);
    if (
      0) {
      a->state = s;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = s;
      a->pause = 1;
      return ACT_RUN;
    }
    if (
      s == loco_ether ||
      0) {
      a->state = loco_ether;
      return ACT_ETHER;
    }
    goto ex;
  }

  /* default start, if not already handled above */
  if (a->state == loco_start) {
    a->state = loco_ether;
    return ACT_ETHER;
  }

  /* default stop, if not already handled above */
  if (a->state == loco_stop) {
    genom_interrupted_detail d;

    assert(a->interruptedby);
    strncpy(d.by, a->interruptedby, sizeof(d.by));
    d.by[sizeof(d.by)-1] = *"";
    s = genom_interrupted(&d, &self->tasks.move.context);
    goto ex;
  }

  /* this cannot happen by construction */
  genom_log_warn(0, "bad state (%s) in task_move",
                 a->state?a->state : "genom_ok");
  abort();
  /*NOTREACHED*/

ex:
  if (
    s != genom_incompatible_digest_id &&
    s != genom_bad_transition_id &&
    s != genom_interrupted_id &&
    s != genom_serialization_id &&
    s != genom_too_many_activities_id &&
    s != genom_disallowed_id &&
    s != genom_mwerr_id &&
    1) {
    genom_bad_transition_detail d;
    strncpy(d.from, a->state, sizeof(d.from)); d.from[sizeof(d.from)-1] = *"";
    strncpy(d.to, s, sizeof(d.to)); d.to[sizeof(d.to)-1] = *"";
    genom_log_warn(
      0, "bad transition from %s to %s in task move",
      a->state, s?s:"genom_ok");
    genom_bad_transition(&d, &self->tasks.move.context);
  }

  a->state = NULL;
  return ACT_ETHER;
}


/* --- service StartMove ------------------------------------------------ */

/* state start */
static __inline__ genom_event
loco_codel_service_StartMove_start(
  struct genom_component_data *self, struct genom_activity *activity)
{
  (void)activity; /* fix -Wunused-parameter */
  genom_event s;

  genom_take_resource(
    self,
    self->resources.all,

    self->resources.task_move = MoveStart);
  s = MoveStart(&(self->ports.JS.handle), &(self->ports.AR.handle), &(self->ports.POS.handle), &self->tasks.move.context);
  genom_give_resource(self, self->resources.task_move = NULL);

  return s;
}

/* state moteur */
static __inline__ genom_event
loco_codel_service_StartMove_moteur(
  struct genom_component_data *self, struct genom_activity *activity)
{
  (void)activity; /* fix -Wunused-parameter */
  genom_event s;

  genom_take_resource(
    self,
    self->resources.all,

    self->resources.task_move = MoveMot);
  s = MoveMot(&(self->ports.JS.handle), &(self->ids.moteur), &self->tasks.move.context);
  genom_give_resource(self, self->resources.task_move = NULL);

  return s;
}

/* state compute_speed */
static __inline__ genom_event
loco_codel_service_StartMove_compute_speed(
  struct genom_component_data *self, struct genom_activity *activity)
{
  (void)activity; /* fix -Wunused-parameter */
  genom_event s;

  genom_take_resource(
    self,
    self->resources.all,

    self->resources.task_move = MoveSpeed);
  s = MoveSpeed(&(self->ids.moteur), &self->tasks.move.context);
  genom_give_resource(self, self->resources.task_move = NULL);

  return s;
}

/* invoke codels according to StartMove state */
static __inline__ enum genom_activity_status
loco_invoke_service_StartMove(
  struct genom_component_data *self, struct genom_activity *a)
{
  genom_event s;

  genom_log_debug(
    "task move invoking service StartMove %s", a->state);

  if (a->state == loco_start) {
    s = loco_codel_service_StartMove_start(self, a);
    genom_log_debug("service StartMove yielded %s", s);
    if (
      s == loco_moteur ||
      0) {
      a->state = s;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = s;
      a->pause = 1;
      return ACT_RUN;
    }
    if (
      s == loco_ether ||
      0) {
      a->state = loco_ether;
      return ACT_ETHER;
    }
    goto ex;
  }

  if (a->state == loco_moteur) {
    s = loco_codel_service_StartMove_moteur(self, a);
    genom_log_debug("service StartMove yielded %s", s);
    if (
      s == loco_compute_speed ||
      0) {
      a->state = s;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = s;
      a->pause = 1;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = loco_ether;
      return ACT_ETHER;
    }
    goto ex;
  }

  if (a->state == loco_compute_speed) {
    s = loco_codel_service_StartMove_compute_speed(self, a);
    genom_log_debug("service StartMove yielded %s", s);
    if (
      0) {
      a->state = s;
      return ACT_RUN;
    }
    if (
      0) {
      a->state = s;
      a->pause = 1;
      return ACT_RUN;
    }
    if (
      s == loco_ether ||
      0) {
      a->state = loco_ether;
      return ACT_ETHER;
    }
    goto ex;
  }


  /* default stop, if not already handled above */
  if (a->state == loco_stop) {
    genom_interrupted_detail d;

    assert(a->interruptedby);
    strncpy(d.by, a->interruptedby, sizeof(d.by));
    d.by[sizeof(d.by)-1] = *"";
    s = genom_interrupted(&d, &self->tasks.move.context);
    goto ex;
  }

  /* this cannot happen by construction */
  genom_log_warn(0, "bad state (%s) in service_StartMove",
                 a->state?a->state : "genom_ok");
  abort();
  /*NOTREACHED*/

ex:
  if (
    s != genom_incompatible_digest_id &&
    s != genom_bad_transition_id &&
    s != genom_interrupted_id &&
    s != genom_serialization_id &&
    s != genom_too_many_activities_id &&
    s != genom_disallowed_id &&
    s != genom_mwerr_id &&
    s != loco_INVALID_ORDER_id &&
    1) {
    genom_bad_transition_detail d;
    strncpy(d.from, a->state, sizeof(d.from)); d.from[sizeof(d.from)-1] = *"";
    strncpy(d.to, s, sizeof(d.to)); d.to[sizeof(d.to)-1] = *"";
    genom_log_warn(
      0, "bad transition from %s to %s in service StartMove",
      a->state, s?s:"genom_ok");
    genom_bad_transition(&d, &self->tasks.move.context);
  }

  a->state = NULL;
  return ACT_ETHER;
}



/* === task move ======================================================== */

enum genom_activity_status
genom_loco_move_invoke(
  struct genom_component_data *self, struct genom_activity *a)
{
  switch(a->sid) {
    case -1:
      return loco_invoke_task_move(self, a);

    case LOCO_StartMove_RQSTID:
      return loco_invoke_service_StartMove(self, a);
  }

  /* must not happen */
  genom_log_warn(0, "bad activity %d in task move", a->sid);
  abort();
  return ACT_VOID;
}

/* --- Generated by genom 2.99.29. Do not edit -------------------------- */

#include "autoconf/acheader.h"

#include <sys/types.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#include "commonStructLib.h"
#include "h2evnLib.h"
#include "taskLib.h"

#include "loco_parameters.h"
#include "loco_msglib.h"
#include "loco_activity.h"
#include "loco_control_task.h"
#include "typecopy.h"


/* --- local data ---------------------------------------------------------- */

#define CNTRL_TASK_MIN_STACK_SIZE 4096
#define EXEC_TASK_MIN_STACK_SIZE  4096

/* cslib server with context pointer, for reentrant csLib callbacks */
struct CS_SERV_IDS {
  CS_SERV csserv;
  struct genom_component_data *self;
};

static void	loco_abort_activity_rqstcb(SERV_ID csserv, int sid);
static void	loco_connect_port_rqstcb(SERV_ID csserv, int sid);
static void	loco_connect_service_rqstcb(SERV_ID csserv, int sid);
static void	loco_kill_rqstcb(SERV_ID csserv, int sid);
static void	loco_GetCurrentPosition_rqstcb(SERV_ID csserv, int sid);
static void	loco_GetCurrentBattery_rqstcb(SERV_ID csserv, int sid);
static void	loco_GetCurrentMap_rqstcb(SERV_ID csserv, int sid);
static void	loco_GetCurrentArena_rqstcb(SERV_ID csserv, int sid);
static void	loco_MoveStop_rqstcb(SERV_ID csserv, int sid);
static void	loco_BattStop_rqstcb(SERV_ID csserv, int sid);
static void	loco_StartMove_rqstcb(SERV_ID csserv, int sid);
static void	loco_StartBatt_rqstcb(SERV_ID csserv, int sid);
static void *	loco_cntrl_task(void *);


/* --- genom_loco_init -------------------------------------------------- */

void *
genom_loco_init(void)
{
  struct genom_component_data *self;
  char tname[64];

  /* create internal data structure */
  self = malloc(sizeof(*self));
  if (!self) {
    genom_log_warn(1, "cannot create internal data structure");
    return NULL;
  }

  genom_tinit_t_loco_ids(&self->ids);
  genom_tinit_loco_genom_state_port(&self->ports.genom_state);
  genom_tinit_loco_genom_metadata_port(&self->ports.genom_metadata);
  genom_tinit_loco_JS_port(&self->ports.JS);
  genom_tinit_loco_AR_port(&self->ports.AR);
  genom_tinit_loco_POS_port(&self->ports.POS);
  genom_tinit_loco_BAT_port(&self->ports.BAT);

  self->tasks.move.context.raise = genom_pocolibs_raise;
  self->tasks.move.context.raised = genom_pocolibs_raised;
  self->tasks.move.context.data =
    &self->tasks.move.context_data;

  self->tasks.move.context_data.self = self;
  self->tasks.move.context_data.ex = genom_ok;
  self->tasks.move.context_data.exdetail = NULL;
  self->tasks.move.context_data.exsize = 0;

  self->tasks.move.taskid = ERROR;

  self->tasks.move.rusage.cycles = 0;
  self->tasks.move.rusage.timings.last = 0.;
  self->tasks.move.rusage.timings.max = 0.;
  self->tasks.move.rusage.timings.avg = 0.;
  self->tasks.move.rusage.load.last = 0.;
  self->tasks.move.rusage.load.max = 0.;
  self->tasks.move.rusage.load.avg = 0.;
  pthread_spin_init(&self->tasks.move.rlock, 0);

  self->tasks.move.runnable = 1;
  self->tasks.move.shutdown = 0;
  {
    size_t i;
    for(i = 0; i < genom_max_activities(); i++)
      self->tasks.move.activities.a[i].any.status = ACT_VOID;
    i = genom_loco_activity_alloc(&self->tasks.move.activities);
    assert(i == 0);
    self->tasks.move.permanent =
      &self->tasks.move.activities.a[i].any;
  }
  self->tasks.move.permanent->sid = -1;
  self->tasks.move.permanent->rid = -1;
  self->tasks.move.permanent->status = ACT_INIT;
  self->tasks.move.permanent->start = 1;

  pthread_mutex_init(&self->tasks.move.lock, NULL);
  pthread_cond_init(&self->tasks.move.sync, NULL);

  self->tasks.batt.context.raise = genom_pocolibs_raise;
  self->tasks.batt.context.raised = genom_pocolibs_raised;
  self->tasks.batt.context.data =
    &self->tasks.batt.context_data;

  self->tasks.batt.context_data.self = self;
  self->tasks.batt.context_data.ex = genom_ok;
  self->tasks.batt.context_data.exdetail = NULL;
  self->tasks.batt.context_data.exsize = 0;

  self->tasks.batt.taskid = ERROR;

  self->tasks.batt.rusage.cycles = 0;
  self->tasks.batt.rusage.timings.last = 0.;
  self->tasks.batt.rusage.timings.max = 0.;
  self->tasks.batt.rusage.timings.avg = 0.;
  self->tasks.batt.rusage.load.last = 0.;
  self->tasks.batt.rusage.load.max = 0.;
  self->tasks.batt.rusage.load.avg = 0.;
  pthread_spin_init(&self->tasks.batt.rlock, 0);

  self->tasks.batt.runnable = 1;
  self->tasks.batt.shutdown = 0;
  {
    size_t i;
    for(i = 0; i < genom_max_activities(); i++)
      self->tasks.batt.activities.a[i].any.status = ACT_VOID;
    i = genom_loco_activity_alloc(&self->tasks.batt.activities);
    assert(i == 0);
    self->tasks.batt.permanent =
      &self->tasks.batt.activities.a[i].any;
  }
  self->tasks.batt.permanent->sid = -1;
  self->tasks.batt.permanent->rid = -1;
  self->tasks.batt.permanent->status = ACT_INIT;
  self->tasks.batt.permanent->start = 1;

  pthread_mutex_init(&self->tasks.batt.lock, NULL);
  pthread_cond_init(&self->tasks.batt.sync, NULL);

  self->control.context.raise = genom_pocolibs_raise;
  self->control.context.raised = genom_pocolibs_raised;

  self->control.context.data = &self->control.context_data;
  self->control.context_data.self = self;
  self->control.context_data.ex = genom_ok;
  self->control.context_data.exdetail = NULL;
  self->control.context_data.exsize = 0;

  self->control.taskid = ERROR;
  snprintf(self->control.mbox_name, sizeof(self->control.mbox_name),
           "%s", genom_instance);
  self->control.csserv = NULL;
  self->control.shutdown = 0;
  self->control.activity.any.status = ACT_VOID;
  memset(self->control.run_map, 0, sizeof(self->control.run_map));
  pthread_spin_init(&self->control.rlock, 0);
  pthread_mutex_init(&self->control.lock, NULL);
  pthread_cond_init(&self->control.sync, NULL);

  self->resources.all = 0;
  self->resources.control = NULL;
  self->resources.task_move = NULL;
  self->resources.task_batt = NULL;
  self->resources.q = 0;
  self->resources.qnext = 0;
  pthread_mutex_init(&self->resources.lock, NULL);
  pthread_cond_init(&self->resources.sync, NULL);

  /* create posters */
  if (genom_metadata_loco_init(self)) goto error;
  if (genom_state_loco_init(self)) goto error;
  if (genom_loco_genom_state_open(&self->control.context)) goto error;
  if (genom_loco_genom_metadata_open(&self->control.context)) goto error;
  if (genom_loco_JS_open(&self->control.context)) goto error;
  if (genom_loco_AR_open(&self->control.context)) goto error;
  if (genom_loco_POS_open(&self->control.context)) goto error;
  if (genom_loco_BAT_open(&self->control.context)) goto error;
  if (genom_loco_genom_metadata_write(&self->control.context)) goto error;
  if (genom_loco_genom_state_write(&self->control.context)) goto error;

  /* spawn move task */
  snprintf(tname, sizeof(tname), "%s/%s", genom_instance, "move");
  pthread_mutex_lock(&self->tasks.move.lock);
  self->tasks.move.taskid =
    taskSpawn2(tname, 255,
               VX_FP_TASK, EXEC_TASK_MIN_STACK_SIZE + 8388608,
               genom_loco_move_exec_task, self);
  while (self->tasks.move.taskid != ERROR &&
         self->tasks.move.permanent->start)
    pthread_cond_wait(&self->tasks.move.sync,
                      &self->tasks.move.lock);

  genom_state_loco_update(self, &self->tasks.move.activities,
    loco_move_TASKID);
  if (self->tasks.move.taskid == ERROR) {
    genom_log_warn(1, "cannot spawn %s exec task", "move");
    pthread_mutex_unlock(&self->tasks.move.lock);
    goto error;
  }
  if (self->tasks.move.permanent->status == ACT_ETHER &&
      self->tasks.move.permanent->state != loco_ether) {
    genom_log_warn(0, "%s exec task failed", "move");
    pthread_mutex_unlock(&self->tasks.move.lock);
    goto error;
  }
  pthread_mutex_unlock(&self->tasks.move.lock);
  genom_state_loco_refresh(self);

  /* spawn batt task */
  snprintf(tname, sizeof(tname), "%s/%s", genom_instance, "batt");
  pthread_mutex_lock(&self->tasks.batt.lock);
  self->tasks.batt.taskid =
    taskSpawn2(tname, 255,
               VX_FP_TASK, EXEC_TASK_MIN_STACK_SIZE + 8388608,
               genom_loco_batt_exec_task, self);
  while (self->tasks.batt.taskid != ERROR &&
         self->tasks.batt.permanent->start)
    pthread_cond_wait(&self->tasks.batt.sync,
                      &self->tasks.batt.lock);

  genom_state_loco_update(self, &self->tasks.batt.activities,
    loco_batt_TASKID);
  if (self->tasks.batt.taskid == ERROR) {
    genom_log_warn(1, "cannot spawn %s exec task", "batt");
    pthread_mutex_unlock(&self->tasks.batt.lock);
    goto error;
  }
  if (self->tasks.batt.permanent->status == ACT_ETHER &&
      self->tasks.batt.permanent->state != loco_ether) {
    genom_log_warn(0, "%s exec task failed", "batt");
    pthread_mutex_unlock(&self->tasks.batt.lock);
    goto error;
  }
  pthread_mutex_unlock(&self->tasks.batt.lock);
  genom_state_loco_refresh(self);


  /* spawn control task */
  snprintf(tname, sizeof(tname), "%s", genom_instance);
  pthread_mutex_lock(&self->control.lock);
  if (taskSpawn2(tname, 10 /* priority */,
                 VX_FP_TASK, LOCO_MAX_RQST_SIZE + LOCO_MAX_REPLY_SIZE
                 + CNTRL_TASK_MIN_STACK_SIZE /*size*/,
                 loco_cntrl_task, self) == ERROR) {
    genom_log_warn(1, "cannot spawn control task");
    pthread_mutex_unlock(&self->control.lock);
    goto error;
  }
  while (self->control.taskid == ERROR)
    pthread_cond_wait(&self->control.sync, &self->control.lock);
  if (self->control.taskid == 0) {
    self->control.taskid = ERROR;
    pthread_mutex_unlock(&self->control.lock);
    goto error;
  }
  pthread_mutex_unlock(&self->control.lock);

  genom_log_info("setup and running");
  return self;

error:
  genom_loco_fini(self);
  return NULL;
}


/* --- genom_loco_fini -------------------------------------------------- */

void
genom_loco_fini(void *data)
{
  struct genom_component_data *self = data;

  /* interrupt & wait for all regular activities */
  if (self->tasks.move.taskid != ERROR) {
    struct genom_activity *a;
    int delay;
    size_t id;

    genom_log_debug("interrupting task move activities");
    pthread_mutex_lock(&self->tasks.move.lock);
    do {
      delay = 0;
      for(id = 0; id < genom_max_activities(); id++) {
        a = &self->tasks.move.activities.a[id].any;
        if (a == self->tasks.move.permanent) continue;

        if (a->status == ACT_INIT || a->status == ACT_RUN) {
          if (!a->stop) {
            a->stop = 1;
            a->interruptedby = "kill";
            if (!self->tasks.move.runnable) {
              self->tasks.move.runnable = 1;
              pthread_cond_broadcast(&self->tasks.move.sync);
            }
          }
          delay = 1;
        } else if (a->status == ACT_STOP)
          delay = 1;
      }
      if (delay)
        pthread_cond_wait(&self->tasks.move.sync,
                          &self->tasks.move.lock);
    } while(delay);
    pthread_mutex_unlock(&self->tasks.move.lock);
  }

  if (self->tasks.batt.taskid != ERROR) {
    struct genom_activity *a;
    int delay;
    size_t id;

    genom_log_debug("interrupting task batt activities");
    pthread_mutex_lock(&self->tasks.batt.lock);
    do {
      delay = 0;
      for(id = 0; id < genom_max_activities(); id++) {
        a = &self->tasks.batt.activities.a[id].any;
        if (a == self->tasks.batt.permanent) continue;

        if (a->status == ACT_INIT || a->status == ACT_RUN) {
          if (!a->stop) {
            a->stop = 1;
            a->interruptedby = "kill";
            if (!self->tasks.batt.runnable) {
              self->tasks.batt.runnable = 1;
              pthread_cond_broadcast(&self->tasks.batt.sync);
            }
          }
          delay = 1;
        } else if (a->status == ACT_STOP)
          delay = 1;
      }
      if (delay)
        pthread_cond_wait(&self->tasks.batt.sync,
                          &self->tasks.batt.lock);
    } while(delay);
    pthread_mutex_unlock(&self->tasks.batt.lock);
  }

  /* interrupt permanent activities */
  if (self->tasks.batt.taskid != ERROR) {
    struct genom_activity *a;

    genom_log_debug("interrupting task batt");
    pthread_mutex_lock(&self->tasks.batt.lock);

    a = self->tasks.batt.permanent;
    if (!a) {
      /* activity was ether, realloc one */
      int i = genom_loco_activity_alloc(
        &self->tasks.batt.activities);
      assert(i>=0);
      a = &self->tasks.batt.activities.a[i].any;
      a->sid = a->rid = -1;
    }
    if (a->status != ACT_STOP) {
      if (a->status == ACT_ETHER) a->status = ACT_INIT;
      a->stop = 1;
      a->interruptedby = "kill";
      self->tasks.batt.permanent = a;
      self->tasks.batt.runnable = 1;
      pthread_cond_broadcast(&self->tasks.batt.sync);
    }
    while(self->tasks.batt.permanent &&
          self->tasks.batt.permanent->status != ACT_ETHER)
      pthread_cond_wait(&self->tasks.batt.sync,
                        &self->tasks.batt.lock);

    pthread_mutex_unlock(&self->tasks.batt.lock);
  }

  if (self->tasks.move.taskid != ERROR) {
    struct genom_activity *a;

    genom_log_debug("interrupting task move");
    pthread_mutex_lock(&self->tasks.move.lock);

    a = self->tasks.move.permanent;
    if (!a) {
      /* activity was ether, realloc one */
      int i = genom_loco_activity_alloc(
        &self->tasks.move.activities);
      assert(i>=0);
      a = &self->tasks.move.activities.a[i].any;
      a->sid = a->rid = -1;
    }
    if (a->status != ACT_STOP) {
      if (a->status == ACT_ETHER) a->status = ACT_INIT;
      a->stop = 1;
      a->interruptedby = "kill";
      self->tasks.move.permanent = a;
      self->tasks.move.runnable = 1;
      pthread_cond_broadcast(&self->tasks.move.sync);
    }
    while(self->tasks.move.permanent &&
          self->tasks.move.permanent->status != ACT_ETHER)
      pthread_cond_wait(&self->tasks.move.sync,
                        &self->tasks.move.lock);

    pthread_mutex_unlock(&self->tasks.move.lock);
  }

  /* wait for exec tasks */
  genom_log_debug("waiting task batt");
  pthread_mutex_lock(&self->tasks.batt.lock);
  self->tasks.batt.shutdown = 1;
  self->tasks.batt.runnable = 1;
  pthread_cond_broadcast(&self->tasks.batt.sync);
  while (self->tasks.batt.taskid != ERROR) {
    pthread_cond_wait(&self->tasks.batt.sync,
                      &self->tasks.batt.lock);
  }
  pthread_mutex_unlock(&self->tasks.batt.lock);

  genom_log_debug("waiting task move");
  pthread_mutex_lock(&self->tasks.move.lock);
  self->tasks.move.shutdown = 1;
  self->tasks.move.runnable = 1;
  pthread_cond_broadcast(&self->tasks.move.sync);
  while (self->tasks.move.taskid != ERROR) {
    pthread_cond_wait(&self->tasks.move.sync,
                      &self->tasks.move.lock);
  }
  pthread_mutex_unlock(&self->tasks.move.lock);


  /* wait for control task */
  if (self->control.taskid != ERROR) {
    genom_log_debug("waiting control task");
    pthread_mutex_lock(&self->control.lock);
    self->control.shutdown = 1;
    while (self->control.taskid != 0) {
      genom_loco_schedule_cntrl(self);
      pthread_cond_wait(&self->control.sync, &self->control.lock);
    }
    pthread_mutex_unlock(&self->control.lock);
  }

  /* clean up */
  genom_loco_genom_state_delete(&self->control.context);
  genom_loco_genom_metadata_delete(&self->control.context);
  genom_loco_JS_delete(&self->control.context);
  genom_loco_AR_delete(&self->control.context);
  genom_loco_POS_delete(&self->control.context);
  genom_loco_BAT_delete(&self->control.context);

  genom_tfini_loco_genom_state_port(&self->ports.genom_state);
  genom_tfini_loco_genom_metadata_port(&self->ports.genom_metadata);
  genom_tfini_loco_JS_port(&self->ports.JS);
  genom_tfini_loco_AR_port(&self->ports.AR);
  genom_tfini_loco_POS_port(&self->ports.POS);
  genom_tfini_loco_BAT_port(&self->ports.BAT);
  genom_tfini_t_loco_ids(&self->ids);
  free(self);
  genom_log_info("shutdown complete");
}


/* --- genom_loco_schedule_cntrl ---------------------------------------- */

void
genom_loco_schedule_cntrl(struct genom_component_data *self)
{
  if (self->control.taskid == ERROR) return;
  h2evnSignal(self->control.taskid);
}


/* --- loco_cntrl_task(void) -------------------------------------------- */

static void *
loco_cntrl_task(void *data)
{
  struct genom_component_data *self = data;
  int e;

  /* create requests reception mailbox */
  if (csMboxInit(self->control.mbox_name, LOCO_MBOX_RQST_SIZE, 0) != OK) {
    genom_log_warn(1, "cannot create server mailbox");
    pthread_mutex_lock(&self->control.lock);
    self->control.taskid = 0;
    pthread_cond_broadcast(&self->control.sync);
    pthread_mutex_unlock(&self->control.lock);
    return NULL;
  }

  /* configure as a server */
  if (csServInitN(
	LOCO_MAX_RQST_SIZE,
	LOCO_MAX_REPLY_SIZE >= LOCO_MAX_INTERMED_REPLY_SIZE ?
	LOCO_MAX_REPLY_SIZE : LOCO_MAX_INTERMED_REPLY_SIZE,
	LOCO_NRQSTID, &self->control.csserv) != OK) {
    genom_log_warn(1, "cannot initialize server mailbox");
    goto error;
  }
  /* fiddle with returned CS_SERV structure, to store ids for callbacks */
  self->control.csserv =
    realloc(self->control.csserv, sizeof(struct CS_SERV_IDS));
  ((struct CS_SERV_IDS *)self->control.csserv)->self = self;

  /* install services callbacks */
  if (csServFuncInstall(self->control.csserv, LOCO_abort_activity_RQSTID,
                        (FUNCPTR)loco_abort_activity_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service abort_activity");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, LOCO_connect_port_RQSTID,
                        (FUNCPTR)loco_connect_port_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service connect_port");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, LOCO_connect_service_RQSTID,
                        (FUNCPTR)loco_connect_service_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service connect_service");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, LOCO_kill_RQSTID,
                        (FUNCPTR)loco_kill_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service kill");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, LOCO_GetCurrentPosition_RQSTID,
                        (FUNCPTR)loco_GetCurrentPosition_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service GetCurrentPosition");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, LOCO_GetCurrentBattery_RQSTID,
                        (FUNCPTR)loco_GetCurrentBattery_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service GetCurrentBattery");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, LOCO_GetCurrentMap_RQSTID,
                        (FUNCPTR)loco_GetCurrentMap_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service GetCurrentMap");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, LOCO_GetCurrentArena_RQSTID,
                        (FUNCPTR)loco_GetCurrentArena_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service GetCurrentArena");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, LOCO_MoveStop_RQSTID,
                        (FUNCPTR)loco_MoveStop_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service MoveStop");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, LOCO_BattStop_RQSTID,
                        (FUNCPTR)loco_BattStop_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service BattStop");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, LOCO_StartMove_RQSTID,
                        (FUNCPTR)loco_StartMove_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service StartMove");
    goto error;
  }
  if (csServFuncInstall(self->control.csserv, LOCO_StartBatt_RQSTID,
                        (FUNCPTR)loco_StartBatt_rqstcb) != OK) {
    genom_log_warn(1, "cannot serve service StartBatt");
    goto error;
  }

  /* signal parent */
  genom_log_info("spawned control task");
  pthread_mutex_lock(&self->control.lock);
  self->control.taskid = taskIdSelf();
  pthread_cond_broadcast(&self->control.sync);
  pthread_mutex_unlock(&self->control.lock);

  do {
    if (self->control.shutdown) {
      /* the task must sleep with h2evnSusp(), so there is no way to atomically
       * check for the shutdown flag. So do not bother taking the mutex.
       * The genom_loco_fini() function will signal an h2evn, after
       * setting the shutdown flag, so it shouldn't exist any race. */
      break;
    }

    /* read reception mailbox status and sleep if there is no message */
    e = csMboxStatus(RCV_MBOX);
    switch(e) {
      case 0: /* no message */
        /* update state port before sleeping */
        genom_state_loco_refresh(self);

        e = h2evnSusp(0);
        if (e != TRUE) {
          genom_log_warn(1, "someone did something nasty");
          genom_log_warn(0, "aborting");
          abort();
        }
        genom_log_debug("control task wake up");

        /* update reception mailbox status */
        e = csMboxStatus(RCV_MBOX);
        if (e != RCV_MBOX) /* awoken by internal event */ break;

        /*FALLTHROUGH*/
      case RCV_MBOX: /* incoming request */
        if (csServRqstExec(self->control.csserv) != OK) {
          genom_log_warn(1, "cannot read reception mailbox");
          genom_log_warn(0, "aborting");
          abort();
        }
        break;

      case ERROR:
        genom_log_warn(1, "cannot check reception mailbox");
        genom_log_warn(0, "aborting");
        abort();
    }


    /* process pending activities */
    pthread_mutex_lock(&self->tasks.move.lock);
    {
      struct genom_activity *a;
      size_t id;

      for(id = 0; id < genom_max_activities(); id++) {
        a = &self->tasks.move.activities.a[id].any;
        switch(a->status) {
          case ACT_VOID: case ACT_RUN: case ACT_STOP: continue;

          case ACT_INIT: {
            int delay;
            if (!a->start) {
              pthread_mutex_unlock(&self->tasks.move.lock);
              delay = genom_loco_interrupt_reqd(self, a);
              pthread_mutex_lock(&self->tasks.move.lock);
              if (!delay) {
                a->start = 1;
                if (!self->tasks.move.runnable) {
                  self->tasks.move.runnable = 1;
                  pthread_cond_broadcast(&self->tasks.move.sync);
                }
              }
            }
            break;
          }

          case ACT_ETHER:
            if (a == self->tasks.move.permanent)
              self->tasks.move.permanent = NULL;
            else {
              pthread_mutex_unlock(&self->tasks.move.lock);
              genom_loco_activity_report(self, a);
              pthread_mutex_lock(&self->tasks.move.lock);
            }
            a->status = ACT_VOID;
            genom_state_loco_update(
              self, &self->tasks.move.activities,
              loco_move_TASKID);
            break;
        }
      }
    }
    pthread_mutex_unlock(&self->tasks.move.lock);
    pthread_mutex_lock(&self->tasks.batt.lock);
    {
      struct genom_activity *a;
      size_t id;

      for(id = 0; id < genom_max_activities(); id++) {
        a = &self->tasks.batt.activities.a[id].any;
        switch(a->status) {
          case ACT_VOID: case ACT_RUN: case ACT_STOP: continue;

          case ACT_INIT: {
            int delay;
            if (!a->start) {
              pthread_mutex_unlock(&self->tasks.batt.lock);
              delay = genom_loco_interrupt_reqd(self, a);
              pthread_mutex_lock(&self->tasks.batt.lock);
              if (!delay) {
                a->start = 1;
                if (!self->tasks.batt.runnable) {
                  self->tasks.batt.runnable = 1;
                  pthread_cond_broadcast(&self->tasks.batt.sync);
                }
              }
            }
            break;
          }

          case ACT_ETHER:
            if (a == self->tasks.batt.permanent)
              self->tasks.batt.permanent = NULL;
            else {
              pthread_mutex_unlock(&self->tasks.batt.lock);
              genom_loco_activity_report(self, a);
              pthread_mutex_lock(&self->tasks.batt.lock);
            }
            a->status = ACT_VOID;
            genom_state_loco_update(
              self, &self->tasks.batt.activities,
              loco_batt_TASKID);
            break;
        }
      }
    }
    pthread_mutex_unlock(&self->tasks.batt.lock);
  } while(1);

  genom_log_info("shutting down control task");

error:
  if (self->control.csserv) csServEnd(self->control.csserv);
  csMboxEnd();

  pthread_mutex_lock(&self->control.lock);
  self->control.taskid = 0;
  pthread_cond_broadcast(&self->control.sync);
  pthread_mutex_unlock(&self->control.lock);
  return NULL;
}


/* --- Service callbacks --------------------------------------------------- */


static void
loco_abort_activity_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_loco_abort_activity_activity *a;
  STATUS s;

  genom_log_debug("handling request for abort_activity");

  /* get an activity slot */
  a = &self->control.activity.s_abort_activity;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = LOCO_abort_activity_RQSTID;
  a->h.rid = rid;
  genom_tinit_loco_abort_activity_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_loco_abort_activity_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "abort_activity");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_loco_abort_activity_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.move.lock);
  if (!self->tasks.move.runnable) {
    self->tasks.move.runnable = 1;
    pthread_cond_broadcast(&self->tasks.move.sync);
  }
  pthread_mutex_unlock(&self->tasks.move.lock);
  pthread_mutex_lock(&self->tasks.batt.lock);
  if (!self->tasks.batt.runnable) {
    self->tasks.batt.runnable = 1;
    pthread_cond_broadcast(&self->tasks.batt.sync);
  }
  pthread_mutex_unlock(&self->tasks.batt.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_loco_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[LOCO_abort_activity_RQSTID] = 1;

  /* send final reply */
  a->h.state = loco_ether;
  genom_loco_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
loco_connect_port_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_loco_connect_port_activity *a;
  STATUS s;

  genom_log_debug("handling request for connect_port");

  /* get an activity slot */
  a = &self->control.activity.s_connect_port;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = LOCO_connect_port_RQSTID;
  a->h.rid = rid;
  genom_tinit_loco_connect_port_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_loco_connect_port_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "connect_port");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_loco_connect_port_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.move.lock);
  if (!self->tasks.move.runnable) {
    self->tasks.move.runnable = 1;
    pthread_cond_broadcast(&self->tasks.move.sync);
  }
  pthread_mutex_unlock(&self->tasks.move.lock);
  pthread_mutex_lock(&self->tasks.batt.lock);
  if (!self->tasks.batt.runnable) {
    self->tasks.batt.runnable = 1;
    pthread_cond_broadcast(&self->tasks.batt.sync);
  }
  pthread_mutex_unlock(&self->tasks.batt.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_loco_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[LOCO_connect_port_RQSTID] = 1;

  /* send final reply */
  a->h.state = loco_ether;
  genom_loco_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
loco_connect_service_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_loco_connect_service_activity *a;
  STATUS s;

  genom_log_debug("handling request for connect_service");

  /* get an activity slot */
  a = &self->control.activity.s_connect_service;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = LOCO_connect_service_RQSTID;
  a->h.rid = rid;
  genom_tinit_loco_connect_service_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_loco_connect_service_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "connect_service");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_loco_connect_service_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.move.lock);
  if (!self->tasks.move.runnable) {
    self->tasks.move.runnable = 1;
    pthread_cond_broadcast(&self->tasks.move.sync);
  }
  pthread_mutex_unlock(&self->tasks.move.lock);
  pthread_mutex_lock(&self->tasks.batt.lock);
  if (!self->tasks.batt.runnable) {
    self->tasks.batt.runnable = 1;
    pthread_cond_broadcast(&self->tasks.batt.sync);
  }
  pthread_mutex_unlock(&self->tasks.batt.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_loco_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[LOCO_connect_service_RQSTID] = 1;

  /* send final reply */
  a->h.state = loco_ether;
  genom_loco_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
loco_kill_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_loco_kill_activity *a;
  STATUS s;

  genom_log_debug("handling request for kill");

  /* get an activity slot */
  a = &self->control.activity.s_kill;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = LOCO_kill_RQSTID;
  a->h.rid = rid;
  genom_tinit_loco_kill_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_loco_kill_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "kill");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_loco_kill_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.move.lock);
  if (!self->tasks.move.runnable) {
    self->tasks.move.runnable = 1;
    pthread_cond_broadcast(&self->tasks.move.sync);
  }
  pthread_mutex_unlock(&self->tasks.move.lock);
  pthread_mutex_lock(&self->tasks.batt.lock);
  if (!self->tasks.batt.runnable) {
    self->tasks.batt.runnable = 1;
    pthread_cond_broadcast(&self->tasks.batt.sync);
  }
  pthread_mutex_unlock(&self->tasks.batt.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_loco_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[LOCO_kill_RQSTID] = 1;

  /* send final reply */
  a->h.state = loco_ether;
  genom_loco_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
loco_GetCurrentPosition_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_loco_GetCurrentPosition_activity *a;
  STATUS s;

  genom_log_debug("handling request for GetCurrentPosition");

  /* get an activity slot */
  a = &self->control.activity.s_GetCurrentPosition;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = LOCO_GetCurrentPosition_RQSTID;
  a->h.rid = rid;
  genom_tinit_loco_GetCurrentPosition_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_loco_GetCurrentPosition_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "GetCurrentPosition");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_loco_GetCurrentPosition_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.move.lock);
  if (!self->tasks.move.runnable) {
    self->tasks.move.runnable = 1;
    pthread_cond_broadcast(&self->tasks.move.sync);
  }
  pthread_mutex_unlock(&self->tasks.move.lock);
  pthread_mutex_lock(&self->tasks.batt.lock);
  if (!self->tasks.batt.runnable) {
    self->tasks.batt.runnable = 1;
    pthread_cond_broadcast(&self->tasks.batt.sync);
  }
  pthread_mutex_unlock(&self->tasks.batt.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_loco_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[LOCO_GetCurrentPosition_RQSTID] = 1;

  /* send final reply */
  a->h.state = loco_ether;
  genom_loco_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
loco_GetCurrentBattery_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_loco_GetCurrentBattery_activity *a;
  STATUS s;

  genom_log_debug("handling request for GetCurrentBattery");

  /* get an activity slot */
  a = &self->control.activity.s_GetCurrentBattery;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = LOCO_GetCurrentBattery_RQSTID;
  a->h.rid = rid;
  genom_tinit_loco_GetCurrentBattery_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_loco_GetCurrentBattery_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "GetCurrentBattery");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_loco_GetCurrentBattery_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.move.lock);
  if (!self->tasks.move.runnable) {
    self->tasks.move.runnable = 1;
    pthread_cond_broadcast(&self->tasks.move.sync);
  }
  pthread_mutex_unlock(&self->tasks.move.lock);
  pthread_mutex_lock(&self->tasks.batt.lock);
  if (!self->tasks.batt.runnable) {
    self->tasks.batt.runnable = 1;
    pthread_cond_broadcast(&self->tasks.batt.sync);
  }
  pthread_mutex_unlock(&self->tasks.batt.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_loco_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[LOCO_GetCurrentBattery_RQSTID] = 1;

  /* send final reply */
  a->h.state = loco_ether;
  genom_loco_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
loco_GetCurrentMap_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_loco_GetCurrentMap_activity *a;
  STATUS s;

  genom_log_debug("handling request for GetCurrentMap");

  /* get an activity slot */
  a = &self->control.activity.s_GetCurrentMap;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = LOCO_GetCurrentMap_RQSTID;
  a->h.rid = rid;
  genom_tinit_loco_GetCurrentMap_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_loco_GetCurrentMap_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "GetCurrentMap");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_loco_GetCurrentMap_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.move.lock);
  if (!self->tasks.move.runnable) {
    self->tasks.move.runnable = 1;
    pthread_cond_broadcast(&self->tasks.move.sync);
  }
  pthread_mutex_unlock(&self->tasks.move.lock);
  pthread_mutex_lock(&self->tasks.batt.lock);
  if (!self->tasks.batt.runnable) {
    self->tasks.batt.runnable = 1;
    pthread_cond_broadcast(&self->tasks.batt.sync);
  }
  pthread_mutex_unlock(&self->tasks.batt.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_loco_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[LOCO_GetCurrentMap_RQSTID] = 1;

  /* send final reply */
  a->h.state = loco_ether;
  genom_loco_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
loco_GetCurrentArena_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_loco_GetCurrentArena_activity *a;
  STATUS s;

  genom_log_debug("handling request for GetCurrentArena");

  /* get an activity slot */
  a = &self->control.activity.s_GetCurrentArena;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = LOCO_GetCurrentArena_RQSTID;
  a->h.rid = rid;
  genom_tinit_loco_GetCurrentArena_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_loco_GetCurrentArena_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "GetCurrentArena");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_loco_GetCurrentArena_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.move.lock);
  if (!self->tasks.move.runnable) {
    self->tasks.move.runnable = 1;
    pthread_cond_broadcast(&self->tasks.move.sync);
  }
  pthread_mutex_unlock(&self->tasks.move.lock);
  pthread_mutex_lock(&self->tasks.batt.lock);
  if (!self->tasks.batt.runnable) {
    self->tasks.batt.runnable = 1;
    pthread_cond_broadcast(&self->tasks.batt.sync);
  }
  pthread_mutex_unlock(&self->tasks.batt.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_loco_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[LOCO_GetCurrentArena_RQSTID] = 1;

  /* send final reply */
  a->h.state = loco_ether;
  genom_loco_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
loco_MoveStop_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_loco_MoveStop_activity *a;
  STATUS s;

  genom_log_debug("handling request for MoveStop");

  /* get an activity slot */
  a = &self->control.activity.s_MoveStop;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = LOCO_MoveStop_RQSTID;
  a->h.rid = rid;
  genom_tinit_loco_MoveStop_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_loco_MoveStop_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "MoveStop");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_loco_MoveStop_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.move.lock);
  if (!self->tasks.move.runnable) {
    self->tasks.move.runnable = 1;
    pthread_cond_broadcast(&self->tasks.move.sync);
  }
  pthread_mutex_unlock(&self->tasks.move.lock);
  pthread_mutex_lock(&self->tasks.batt.lock);
  if (!self->tasks.batt.runnable) {
    self->tasks.batt.runnable = 1;
    pthread_cond_broadcast(&self->tasks.batt.sync);
  }
  pthread_mutex_unlock(&self->tasks.batt.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_loco_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[LOCO_MoveStop_RQSTID] = 1;

  /* send final reply */
  a->h.state = loco_ether;
  genom_loco_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
loco_BattStop_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_loco_BattStop_activity *a;
  STATUS s;

  genom_log_debug("handling request for BattStop");

  /* get an activity slot */
  a = &self->control.activity.s_BattStop;
  assert(a->h.status == ACT_VOID);
  a->h.status = ACT_INIT;
  a->h.sid = LOCO_BattStop_RQSTID;
  a->h.rid = rid;
  genom_tinit_loco_BattStop_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_loco_BattStop_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "BattStop");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_loco_BattStop_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.move.lock);
  if (!self->tasks.move.runnable) {
    self->tasks.move.runnable = 1;
    pthread_cond_broadcast(&self->tasks.move.sync);
  }
  pthread_mutex_unlock(&self->tasks.move.lock);
  pthread_mutex_lock(&self->tasks.batt.lock);
  if (!self->tasks.batt.runnable) {
    self->tasks.batt.runnable = 1;
    pthread_cond_broadcast(&self->tasks.batt.sync);
  }
  pthread_mutex_unlock(&self->tasks.batt.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* interrupt incompatible activities */
  genom_loco_interrupt_reqd(self, &a->h);

  /* update after/before array */
  self->control.run_map[LOCO_BattStop_RQSTID] = 1;

  /* send final reply */
  a->h.state = loco_ether;
  genom_loco_activity_report(self, &a->h);
  goto clean;


clean:
  assert(a->h.status == ACT_INIT);
  a->h.status = ACT_VOID;
}


static void
loco_StartMove_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_loco_StartMove_activity *a;
  STATUS s;

  genom_log_debug("handling request for StartMove");

  /* get an activity slot */
  pthread_mutex_lock(&self->tasks.move.lock);
  int id = genom_loco_activity_alloc(&self->tasks.move.activities);
  if (id < 0) {
    pthread_mutex_unlock(&self->tasks.move.lock);
    s = csServReplySend(
      csserv, rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_loco_genom_too_many_activities_encodex);
    if (s == ERROR) assert(!"unexpected failure");
    return;
  }
  a = &self->tasks.move.activities.a[id].s_StartMove;
  pthread_mutex_unlock(&self->tasks.move.lock);
  a->h.sid = LOCO_StartMove_RQSTID;
  a->h.rid = rid;
  genom_tinit_loco_StartMove_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_loco_StartMove_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "StartMove");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_loco_StartMove_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.move.lock);
  if (!self->tasks.move.runnable) {
    self->tasks.move.runnable = 1;
    pthread_cond_broadcast(&self->tasks.move.sync);
  }
  pthread_mutex_unlock(&self->tasks.move.lock);
  pthread_mutex_lock(&self->tasks.batt.lock);
  if (!self->tasks.batt.runnable) {
    self->tasks.batt.runnable = 1;
    pthread_cond_broadcast(&self->tasks.batt.sync);
  }
  pthread_mutex_unlock(&self->tasks.batt.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* update state port */
  pthread_mutex_lock(&self->tasks.move.lock);
  genom_state_loco_update(
              self, &self->tasks.move.activities,
              loco_move_TASKID);
  pthread_mutex_unlock(&self->tasks.move.lock);

  /* send intermediate reply */
  s = csServReplySend(csserv, rid, INTERMED_REPLY, OK,
                      (char *)&a->h.aid, sizeof(int), NULL);
  if (s == ERROR) {
    genom_log_warn(1, "cannot acknowledge service %s", "StartMove");
  }

  return;

clean:
  assert(a->h.status == ACT_INIT);
  pthread_mutex_lock(&self->tasks.move.lock);
  a->h.status = ACT_VOID;
  pthread_mutex_unlock(&self->tasks.move.lock);
}


static void
loco_StartBatt_rqstcb(SERV_ID csserv, int rid)
{
  struct genom_component_data *self = ((struct CS_SERV_IDS *)csserv)->self;
  struct genom_loco_StartBatt_activity *a;
  STATUS s;

  genom_log_debug("handling request for StartBatt");

  /* get an activity slot */
  pthread_mutex_lock(&self->tasks.batt.lock);
  int id = genom_loco_activity_alloc(&self->tasks.batt.activities);
  if (id < 0) {
    pthread_mutex_unlock(&self->tasks.batt.lock);
    s = csServReplySend(
      csserv, rid, FINAL_REPLY, ERROR, NULL, 0,
      genom_loco_genom_too_many_activities_encodex);
    if (s == ERROR) assert(!"unexpected failure");
    return;
  }
  a = &self->tasks.batt.activities.a[id].s_StartBatt;
  pthread_mutex_unlock(&self->tasks.batt.lock);
  a->h.sid = LOCO_StartBatt_RQSTID;
  a->h.rid = rid;
  genom_tinit_loco_StartBatt_activity(a);

  /* decode input */
  s = csServRqstParamsGet(csserv, rid, (char *)&a->in, 0,
                          genom_loco_StartBatt_decode);
  if (s == ERROR) {
    genom_log_warn(0, "invalid input for service %s", "StartBatt");
    a->h.state = genom_serialization_id;
    a->h.exdetail = NULL;
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* run control, validate codel and simple codels */
  a->h.state = genom_loco_StartBatt_controlcb(self, a);

  /* wake up sleeping activities */
  pthread_mutex_lock(&self->tasks.move.lock);
  if (!self->tasks.move.runnable) {
    self->tasks.move.runnable = 1;
    pthread_cond_broadcast(&self->tasks.move.sync);
  }
  pthread_mutex_unlock(&self->tasks.move.lock);
  pthread_mutex_lock(&self->tasks.batt.lock);
  if (!self->tasks.batt.runnable) {
    self->tasks.batt.runnable = 1;
    pthread_cond_broadcast(&self->tasks.batt.sync);
  }
  pthread_mutex_unlock(&self->tasks.batt.lock);

  /* check control codels */
  if (a->h.state) {
    a->h.exdetail = (void *)self->control.context.raised(
      NULL, &self->control.context);
    genom_loco_activity_report(self, &a->h);
    goto clean;
  }

  /* update state port */
  pthread_mutex_lock(&self->tasks.batt.lock);
  genom_state_loco_update(
              self, &self->tasks.batt.activities,
              loco_batt_TASKID);
  pthread_mutex_unlock(&self->tasks.batt.lock);

  /* send intermediate reply */
  s = csServReplySend(csserv, rid, INTERMED_REPLY, OK,
                      (char *)&a->h.aid, sizeof(int), NULL);
  if (s == ERROR) {
    genom_log_warn(1, "cannot acknowledge service %s", "StartBatt");
  }

  return;

clean:
  assert(a->h.status == ACT_INIT);
  pthread_mutex_lock(&self->tasks.batt.lock);
  a->h.status = ACT_VOID;
  pthread_mutex_unlock(&self->tasks.batt.lock);
}


/* eof */

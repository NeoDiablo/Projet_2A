/* --- Generated by genom 2.99.29. Do not edit -------------------------- */

#include "autoconf/acheader.h"

#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>

#include "h2devLib.h"

#include "loco_control_task.h"
#include "loco_portlib.h"
#include "serialize.h"

/* --- local data ---------------------------------------------------------- */

enum {
  loco_PORTLIB_MIN_INDEX = 0,
  loco_genom_state_INDEX,
  loco_genom_metadata_INDEX,
  loco_JS_INDEX,
  loco_AR_INDEX,
  loco_POS_INDEX,
  loco_BAT_INDEX,
  loco_PORTLIB_MAX_INDEX
};

/* --- state port ---------------------------------------------------------- */

int
genom_state_loco_init(struct genom_component_data *self)
{
  genom_state_component *data = &self->ports.genom_state.h.buffer;

  /* task list */
  if (genom_sequence_reserve(&data->task, 2))
    return ENOMEM;
  {
    genom_state_task *task;
    task = &data->task._buffer[loco_move_TASKID];

    snprintf(task->name, sizeof(task->name), "%s", "move");
    task->rusage.cycles = 0;
    task->rusage.timings.last = 0;
    task->rusage.timings.max = 0;
    task->rusage.timings.avg = 0;
    task->rusage.load.last = 0;
    task->rusage.load.max = 0;
    task->rusage.load.avg = 0;
    task->activity._length = 0;
    if (genom_sequence_reserve(&task->activity, genom_max_activities()))
      return ENOMEM;
  }
  {
    genom_state_task *task;
    task = &data->task._buffer[loco_batt_TASKID];

    snprintf(task->name, sizeof(task->name), "%s", "batt");
    task->rusage.cycles = 0;
    task->rusage.timings.last = 0;
    task->rusage.timings.max = 0;
    task->rusage.timings.avg = 0;
    task->rusage.load.last = 0;
    task->rusage.load.max = 0;
    task->rusage.load.avg = 0;
    task->activity._length = 0;
    if (genom_sequence_reserve(&task->activity, genom_max_activities()))
      return ENOMEM;
  }
  data->task._length = 2;

  /* automatic versioning - nice idea borrowed from ROS */
  strncpy(data->digest, "51e2b712528b516da6f0cfe98dc4e8", sizeof(data->digest));
  strncpy(data->date, "Wed Jul 19 15:17:58 CEST 2017", sizeof(data->date));
  strncpy(data->version, "1.0", sizeof(data->version));

  genom_log_debug("initialized genom_state port");
  return 0;
}

int
genom_state_loco_update(struct genom_component_data *self,
                    struct genom_activities *activities, int tnum)
{
  genom_state_component *data = &self->ports.genom_state.h.buffer;
  genom_state_task *t = &data->task._buffer[tnum];
  struct genom_activity *a;
  const char *s;
  size_t i, j;

  for(i = j = 0; i < genom_max_activities(); i++) {
    a = &activities->a[i].any;
    if (a->status == ACT_VOID) continue;

    t->activity._buffer[j].id = a->aid;
    switch(a->sid) {
      case -1: s = "<task>"; break;
      case LOCO_StartMove_RQSTID: s = "StartMove"; break;
      case LOCO_StartBatt_RQSTID: s = "StartBatt"; break;
      default: assert(!"unknown service id"); break;
    }
    snprintf(t->activity._buffer[j].name,
             sizeof(t->activity._buffer[j].name), "%s", s);
    j++;
  }
  t->activity._length = j;
  return 0;
}

genom_event
genom_state_loco_refresh(struct genom_component_data *self)
{
  genom_state_component *data = &self->ports.genom_state.h.buffer;
  genom_state_task *task;
  genom_event s;

  /* task rusage */
  task = &data->task._buffer[loco_move_TASKID];
  pthread_spin_lock(&self->tasks.move.rlock);
  task->rusage = self->tasks.move.rusage;
  pthread_spin_unlock(&self->tasks.move.rlock);
  task = &data->task._buffer[loco_batt_TASKID];
  pthread_spin_lock(&self->tasks.batt.rlock);
  task->rusage = self->tasks.batt.rusage;
  pthread_spin_unlock(&self->tasks.batt.rlock);

  s = self->ports.genom_state.handle.write(&self->control.context);
  if (s) genom_log_warn(0, "cannot update state port: %s", s);
  genom_log_debug("refreshed genom_state port");
  return s;
}


/* --- metadata port ------------------------------------------------------- */

int
genom_metadata_loco_init(struct genom_component_data *self)
{
  pocolibs_metadata_component *meta = &self->ports.genom_metadata.h.buffer;
  size_t l, m;

  genom_sequence_reserve(&meta->services, 12);
  l = sizeof(meta->services._buffer->name);
  m = sizeof(meta->services._buffer->digest);
  meta->services._buffer[0].rqstid = LOCO_abort_activity_RQSTID;
  strncpy(meta->services._buffer[0].name, "abort_activity", l);
  meta->services._buffer[0].name[l-1] = 0;
  strncpy(meta->services._buffer[0].digest, "4385b2f03ea2fe81a32b92a3c0e940", m);
  meta->services._buffer[0].digest[m-1] = 0;
  meta->services._buffer[1].rqstid = LOCO_connect_port_RQSTID;
  strncpy(meta->services._buffer[1].name, "connect_port", l);
  meta->services._buffer[1].name[l-1] = 0;
  strncpy(meta->services._buffer[1].digest, "4c1bd913585cd1265c6ad7aea00421a", m);
  meta->services._buffer[1].digest[m-1] = 0;
  meta->services._buffer[2].rqstid = LOCO_connect_service_RQSTID;
  strncpy(meta->services._buffer[2].name, "connect_service", l);
  meta->services._buffer[2].name[l-1] = 0;
  strncpy(meta->services._buffer[2].digest, "4c1bd913585cd1265c6ad7aea00421a", m);
  meta->services._buffer[2].digest[m-1] = 0;
  meta->services._buffer[3].rqstid = LOCO_kill_RQSTID;
  strncpy(meta->services._buffer[3].name, "kill", l);
  meta->services._buffer[3].name[l-1] = 0;
  strncpy(meta->services._buffer[3].digest, "62357408c1c53751884a1c27b10599", m);
  meta->services._buffer[3].digest[m-1] = 0;
  meta->services._buffer[4].rqstid = LOCO_GetCurrentPosition_RQSTID;
  strncpy(meta->services._buffer[4].name, "GetCurrentPosition", l);
  meta->services._buffer[4].name[l-1] = 0;
  strncpy(meta->services._buffer[4].digest, "4a7ce31639d5e05d5e3d642b206af6f0", m);
  meta->services._buffer[4].digest[m-1] = 0;
  meta->services._buffer[5].rqstid = LOCO_GetCurrentBattery_RQSTID;
  strncpy(meta->services._buffer[5].name, "GetCurrentBattery", l);
  meta->services._buffer[5].name[l-1] = 0;
  strncpy(meta->services._buffer[5].digest, "4ac9b8894418a39cd852ecf5cb9d143", m);
  meta->services._buffer[5].digest[m-1] = 0;
  meta->services._buffer[6].rqstid = LOCO_GetCurrentMap_RQSTID;
  strncpy(meta->services._buffer[6].name, "GetCurrentMap", l);
  meta->services._buffer[6].name[l-1] = 0;
  strncpy(meta->services._buffer[6].digest, "fc57e3ba53274515a776b67d2eda0e8", m);
  meta->services._buffer[6].digest[m-1] = 0;
  meta->services._buffer[7].rqstid = LOCO_GetCurrentArena_RQSTID;
  strncpy(meta->services._buffer[7].name, "GetCurrentArena", l);
  meta->services._buffer[7].name[l-1] = 0;
  strncpy(meta->services._buffer[7].digest, "9ff443adc235e91e47b553fa5bbf", m);
  meta->services._buffer[7].digest[m-1] = 0;
  meta->services._buffer[8].rqstid = LOCO_MoveStop_RQSTID;
  strncpy(meta->services._buffer[8].name, "MoveStop", l);
  meta->services._buffer[8].name[l-1] = 0;
  strncpy(meta->services._buffer[8].digest, "62357408c1c53751884a1c27b10599", m);
  meta->services._buffer[8].digest[m-1] = 0;
  meta->services._buffer[9].rqstid = LOCO_BattStop_RQSTID;
  strncpy(meta->services._buffer[9].name, "BattStop", l);
  meta->services._buffer[9].name[l-1] = 0;
  strncpy(meta->services._buffer[9].digest, "62357408c1c53751884a1c27b10599", m);
  meta->services._buffer[9].digest[m-1] = 0;
  meta->services._buffer[10].rqstid = LOCO_StartMove_RQSTID;
  strncpy(meta->services._buffer[10].name, "StartMove", l);
  meta->services._buffer[10].name[l-1] = 0;
  strncpy(meta->services._buffer[10].digest, "62357408c1c53751884a1c27b10599", m);
  meta->services._buffer[10].digest[m-1] = 0;
  meta->services._buffer[11].rqstid = LOCO_StartBatt_RQSTID;
  strncpy(meta->services._buffer[11].name, "StartBatt", l);
  meta->services._buffer[11].name[l-1] = 0;
  strncpy(meta->services._buffer[11].digest, "62357408c1c53751884a1c27b10599", m);
  meta->services._buffer[11].digest[m-1] = 0;
  meta->services._length = 12;

  genom_log_debug("initialized metadata port");
  return 0;
}

genom_event
genom_metadata_loco_fetch(struct genom_component_data *self,
                      const char *comp, pocolibs_metadata_component *meta)
{
  char name[H2_DEV_MAX_NAME];
  POSTER_ID id;
  char *data;
  STATUS s;
  ssize_t m;
  int n;

  n = snprintf(name, sizeof(name), "%s/genom_metadata", comp);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port %s name too long", name);
    genom_log_warn(0, "port name length limited to %d characters",
                   H2_DEV_MAX_NAME);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG },
                        &self->control.context);
  }

  if (posterFind(name, &id) != OK) {
    genom_log_warn(1, "no such port %s", name);
    return genom_no_such_service(&self->control.context);
  }

  s = posterTake(id, POSTER_READ);
  if (s != OK) {
    genom_log_warn(1, "cannot access metadata port %s", name);
    return genom_no_such_service(&self->control.context);
  }

  data = posterAddr(id);
  m = -1;
  s =
    genom_deserialize_t_pocolibs_metadata_component
    (&data, &m, meta);
  if (s) {
    genom_log_warn(1, "cannot read metadata port %s contents", name);
    return genom_no_such_service(&self->control.context);
  }
  posterGive(id);

  return 0;
}



/* --- genom_loco_genom_state_get_ph ------------------------------------ */

static __inline__ struct genom_loco_genom_state_ph *
genom_loco_genom_state_get_ph(
  struct genom_loco_genom_state_port *p)
{
  return &p->h;
}


/* --- genom_loco_genom_state_data -------------------------------------- */

genom_state_component *
genom_loco_genom_state_data(
  genom_context self)
{
  struct genom_loco_genom_state_port *p;
  struct genom_loco_genom_state_ph *ph;

  p = &self->data->self->ports.genom_state;

  ph = genom_loco_genom_state_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_loco_genom_state_open -------------------------------------- */

genom_event
genom_loco_genom_state_open(
  genom_context self)
{
  struct genom_loco_genom_state_port *p;
  struct genom_loco_genom_state_ph *ph;
  char name[H2_DEV_MAX_NAME];
  STATUS s;
  size_t l;
  int n;

  p = &self->data->self->ports.genom_state;

  n = snprintf(name, sizeof(name), "%s/genom_state", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port genom_state name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  l = genom_maxserialen_t_genom_state_component();

  s = posterCreate(name, (int)l, &ph->id);
  if (s == ERROR) {
    genom_log_warn(1, "cannot create outport %s", name);
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);
  }
  ph->size = l;
  genom_log_info("created outport %s", name);
  return genom_ok;
}


/* --- genom_loco_genom_state_close ------------------------------------- */

genom_event
genom_loco_genom_state_close(
  genom_context self)
{
  struct genom_loco_genom_state_port *p;
  struct genom_loco_genom_state_ph *ph;

  p = &self->data->self->ports.genom_state;

  ph = genom_loco_genom_state_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  posterDelete(ph->id);
  genom_log_info("destroyed outport genom_state");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_loco_genom_state_delete ------------------------------------ */

void
genom_loco_genom_state_delete(genom_context self)
{
  genom_loco_genom_state_close(self);
}


/* --- genom_loco_genom_metadata_get_ph --------------------------------- */

static __inline__ struct genom_loco_genom_metadata_ph *
genom_loco_genom_metadata_get_ph(
  struct genom_loco_genom_metadata_port *p)
{
  return &p->h;
}


/* --- genom_loco_genom_metadata_data ----------------------------------- */

pocolibs_metadata_component *
genom_loco_genom_metadata_data(
  genom_context self)
{
  struct genom_loco_genom_metadata_port *p;
  struct genom_loco_genom_metadata_ph *ph;

  p = &self->data->self->ports.genom_metadata;

  ph = genom_loco_genom_metadata_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_loco_genom_metadata_open ----------------------------------- */

genom_event
genom_loco_genom_metadata_open(
  genom_context self)
{
  struct genom_loco_genom_metadata_port *p;
  struct genom_loco_genom_metadata_ph *ph;
  char name[H2_DEV_MAX_NAME];
  STATUS s;
  size_t l;
  int n;

  p = &self->data->self->ports.genom_metadata;

  n = snprintf(name, sizeof(name), "%s/genom_metadata", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port genom_metadata name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  l = genom_maxserialen_t_pocolibs_metadata_component();

  s = posterCreate(name, (int)l, &ph->id);
  if (s == ERROR) {
    genom_log_warn(1, "cannot create outport %s", name);
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);
  }
  ph->size = l;
  genom_log_info("created outport %s", name);
  return genom_ok;
}


/* --- genom_loco_genom_metadata_close ---------------------------------- */

genom_event
genom_loco_genom_metadata_close(
  genom_context self)
{
  struct genom_loco_genom_metadata_port *p;
  struct genom_loco_genom_metadata_ph *ph;

  p = &self->data->self->ports.genom_metadata;

  ph = genom_loco_genom_metadata_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  posterDelete(ph->id);
  genom_log_info("destroyed outport genom_metadata");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_loco_genom_metadata_delete --------------------------------- */

void
genom_loco_genom_metadata_delete(genom_context self)
{
  genom_loco_genom_metadata_close(self);
}


/* --- genom_loco_JS_get_ph --------------------------------------------- */

static __inline__ struct genom_loco_JS_ph *
genom_loco_JS_get_ph(
  struct genom_loco_JS_port *p)
{
  return &p->h;
}


/* --- genom_loco_JS_data ----------------------------------------------- */

display_order *
genom_loco_JS_data(
  genom_context self)
{
  struct genom_loco_JS_port *p;
  struct genom_loco_JS_ph *ph;

  p = &self->data->self->ports.JS;

  ph = genom_loco_JS_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_loco_JS_open ----------------------------------------------- */

genom_event
genom_loco_JS_open(
  genom_context self)
{
  struct genom_loco_JS_port *p;
  struct genom_loco_JS_ph *ph;
  char name[H2_DEV_MAX_NAME];
  int n;

  p = &self->data->self->ports.JS;

  n = snprintf(name, sizeof(name), "%s/JS", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port JS name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  genom_log_info("created inport %s", name);
  return genom_ok;
}


/* --- genom_loco_JS_close ---------------------------------------------- */

genom_event
genom_loco_JS_close(
  genom_context self)
{
  struct genom_loco_JS_port *p;
  struct genom_loco_JS_ph *ph;

  p = &self->data->self->ports.JS;

  ph = genom_loco_JS_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  genom_log_info("destroyed inport JS");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_loco_JS_delete --------------------------------------------- */

void
genom_loco_JS_delete(genom_context self)
{
  genom_loco_JS_close(self);
}


/* --- genom_loco_AR_get_ph --------------------------------------------- */

static __inline__ struct genom_loco_AR_ph *
genom_loco_AR_get_ph(
  struct genom_loco_AR_port *p)
{
  return &p->h;
}


/* --- genom_loco_AR_data ----------------------------------------------- */

camera_arena *
genom_loco_AR_data(
  genom_context self)
{
  struct genom_loco_AR_port *p;
  struct genom_loco_AR_ph *ph;

  p = &self->data->self->ports.AR;

  ph = genom_loco_AR_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_loco_AR_open ----------------------------------------------- */

genom_event
genom_loco_AR_open(
  genom_context self)
{
  struct genom_loco_AR_port *p;
  struct genom_loco_AR_ph *ph;
  char name[H2_DEV_MAX_NAME];
  int n;

  p = &self->data->self->ports.AR;

  n = snprintf(name, sizeof(name), "%s/AR", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port AR name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  genom_log_info("created inport %s", name);
  return genom_ok;
}


/* --- genom_loco_AR_close ---------------------------------------------- */

genom_event
genom_loco_AR_close(
  genom_context self)
{
  struct genom_loco_AR_port *p;
  struct genom_loco_AR_ph *ph;

  p = &self->data->self->ports.AR;

  ph = genom_loco_AR_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  genom_log_info("destroyed inport AR");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_loco_AR_delete --------------------------------------------- */

void
genom_loco_AR_delete(genom_context self)
{
  genom_loco_AR_close(self);
}


/* --- genom_loco_POS_get_ph -------------------------------------------- */

static __inline__ struct genom_loco_POS_ph *
genom_loco_POS_get_ph(
  struct genom_loco_POS_port *p)
{
  return &p->h;
}


/* --- genom_loco_POS_data ---------------------------------------------- */

camera_robot *
genom_loco_POS_data(
  genom_context self)
{
  struct genom_loco_POS_port *p;
  struct genom_loco_POS_ph *ph;

  p = &self->data->self->ports.POS;

  ph = genom_loco_POS_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_loco_POS_open ---------------------------------------------- */

genom_event
genom_loco_POS_open(
  genom_context self)
{
  struct genom_loco_POS_port *p;
  struct genom_loco_POS_ph *ph;
  char name[H2_DEV_MAX_NAME];
  int n;

  p = &self->data->self->ports.POS;

  n = snprintf(name, sizeof(name), "%s/POS", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port POS name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  genom_log_info("created inport %s", name);
  return genom_ok;
}


/* --- genom_loco_POS_close --------------------------------------------- */

genom_event
genom_loco_POS_close(
  genom_context self)
{
  struct genom_loco_POS_port *p;
  struct genom_loco_POS_ph *ph;

  p = &self->data->self->ports.POS;

  ph = genom_loco_POS_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  genom_log_info("destroyed inport POS");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_loco_POS_delete -------------------------------------------- */

void
genom_loco_POS_delete(genom_context self)
{
  genom_loco_POS_close(self);
}


/* --- genom_loco_BAT_get_ph -------------------------------------------- */

static __inline__ struct genom_loco_BAT_ph *
genom_loco_BAT_get_ph(
  struct genom_loco_BAT_port *p)
{
  return &p->h;
}


/* --- genom_loco_BAT_data ---------------------------------------------- */

loco_data *
genom_loco_BAT_data(
  genom_context self)
{
  struct genom_loco_BAT_port *p;
  struct genom_loco_BAT_ph *ph;

  p = &self->data->self->ports.BAT;

  ph = genom_loco_BAT_get_ph(p);
  if (!ph || !ph->id) return NULL;
  return &(ph->buffer);
}


/* --- genom_loco_BAT_open ---------------------------------------------- */

genom_event
genom_loco_BAT_open(
  genom_context self)
{
  struct genom_loco_BAT_port *p;
  struct genom_loco_BAT_ph *ph;
  char name[H2_DEV_MAX_NAME];
  STATUS s;
  size_t l;
  int n;

  p = &self->data->self->ports.BAT;

  n = snprintf(name, sizeof(name), "%s/BAT", genom_instance);
  if (n <= 0 || n >= (signed)sizeof(name)) {
    genom_log_warn(0, "port BAT name too long");
    genom_log_warn(0, "port name length limited to %zu characters",
                   H2_DEV_MAX_NAME - strlen(genom_instance) - 2);
    return genom_syserr(&(genom_syserr_detail){ .code = ENAMETOOLONG }, self);
  }

  n = 0;
  ph = &p->h;
  ph->id = NULL;

  l = genom_maxserialen_t_loco_data();

  s = posterCreate(name, (int)l, &ph->id);
  if (s == ERROR) {
    genom_log_warn(1, "cannot create outport %s", name);
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);
  }
  ph->size = l;
  genom_log_info("created outport %s", name);
  return genom_ok;
}


/* --- genom_loco_BAT_close --------------------------------------------- */

genom_event
genom_loco_BAT_close(
  genom_context self)
{
  struct genom_loco_BAT_port *p;
  struct genom_loco_BAT_ph *ph;

  p = &self->data->self->ports.BAT;

  ph = genom_loco_BAT_get_ph(p);
  if (!ph || !ph->id)
    return genom_syserr(&(genom_syserr_detail){ .code = ENOENT }, self);

  posterDelete(ph->id);
  genom_log_info("destroyed outport BAT");
  ph->id = NULL;
  return genom_ok;
}


/* --- genom_loco_BAT_delete -------------------------------------------- */

void
genom_loco_BAT_delete(genom_context self)
{
  genom_loco_BAT_close(self);
}



/* --- genom_loco_JS_connect -------------------------------------------- */

genom_event
genom_loco_JS_connect(
  const char *name, genom_context self)
{
  struct genom_loco_JS_port *p =
    &self->data->self->ports.JS;
  struct genom_loco_JS_ph *ph;
  POSTER_ID pid;

  ph = genom_loco_JS_get_ph(p);

  if (!ph) return genom_no_such_inport(self);

  if (posterFind(name, &pid) != OK) {
    genom_log_warn(1, "no such port %s", name);
    return genom_no_such_outport(self);
  }
  if (posterTake(pid, POSTER_READ) != OK) {
    genom_log_warn(1, "cannot connect port %s", name);
    return genom_port_io(self);
  }
  posterGive(pid);

  ph->id = pid;
  return genom_ok;
}


/* --- genom_loco_JS_read ----------------------------------------------- */

genom_event
genom_loco_JS_read(
  genom_context self)
{
  struct genom_loco_JS_port *p;
  struct genom_loco_JS_ph *ph;
  STATUS s;
  char *b;
  ssize_t max;

  p = &self->data->self->ports.JS;

  ph = genom_loco_JS_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_inport(self);

  s = posterTake(ph->id, POSTER_READ);
  if (s != OK) {
    genom_log_warn(1, "cannot access inport JS");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  max = -1;
  s = genom_deserialize_t_display_order(
    &b, &max, &(ph->buffer));
  posterGive(ph->id);
  if (s) {
    genom_log_warn(0, "cannot read inport JS contents");
    return genom_serialization(self);
  }

  return genom_ok;
}


/* --- genom_loco_AR_connect -------------------------------------------- */

genom_event
genom_loco_AR_connect(
  const char *name, genom_context self)
{
  struct genom_loco_AR_port *p =
    &self->data->self->ports.AR;
  struct genom_loco_AR_ph *ph;
  POSTER_ID pid;

  ph = genom_loco_AR_get_ph(p);

  if (!ph) return genom_no_such_inport(self);

  if (posterFind(name, &pid) != OK) {
    genom_log_warn(1, "no such port %s", name);
    return genom_no_such_outport(self);
  }
  if (posterTake(pid, POSTER_READ) != OK) {
    genom_log_warn(1, "cannot connect port %s", name);
    return genom_port_io(self);
  }
  posterGive(pid);

  ph->id = pid;
  return genom_ok;
}


/* --- genom_loco_AR_read ----------------------------------------------- */

genom_event
genom_loco_AR_read(
  genom_context self)
{
  struct genom_loco_AR_port *p;
  struct genom_loco_AR_ph *ph;
  STATUS s;
  char *b;
  ssize_t max;

  p = &self->data->self->ports.AR;

  ph = genom_loco_AR_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_inport(self);

  s = posterTake(ph->id, POSTER_READ);
  if (s != OK) {
    genom_log_warn(1, "cannot access inport AR");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  max = -1;
  s = genom_deserialize_t_camera_arena(
    &b, &max, &(ph->buffer));
  posterGive(ph->id);
  if (s) {
    genom_log_warn(0, "cannot read inport AR contents");
    return genom_serialization(self);
  }

  return genom_ok;
}


/* --- genom_loco_POS_connect ------------------------------------------- */

genom_event
genom_loco_POS_connect(
  const char *name, genom_context self)
{
  struct genom_loco_POS_port *p =
    &self->data->self->ports.POS;
  struct genom_loco_POS_ph *ph;
  POSTER_ID pid;

  ph = genom_loco_POS_get_ph(p);

  if (!ph) return genom_no_such_inport(self);

  if (posterFind(name, &pid) != OK) {
    genom_log_warn(1, "no such port %s", name);
    return genom_no_such_outport(self);
  }
  if (posterTake(pid, POSTER_READ) != OK) {
    genom_log_warn(1, "cannot connect port %s", name);
    return genom_port_io(self);
  }
  posterGive(pid);

  ph->id = pid;
  return genom_ok;
}


/* --- genom_loco_POS_read ---------------------------------------------- */

genom_event
genom_loco_POS_read(
  genom_context self)
{
  struct genom_loco_POS_port *p;
  struct genom_loco_POS_ph *ph;
  STATUS s;
  char *b;
  ssize_t max;

  p = &self->data->self->ports.POS;

  ph = genom_loco_POS_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_inport(self);

  s = posterTake(ph->id, POSTER_READ);
  if (s != OK) {
    genom_log_warn(1, "cannot access inport POS");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  max = -1;
  s = genom_deserialize_t_camera_robot(
    &b, &max, &(ph->buffer));
  posterGive(ph->id);
  if (s) {
    genom_log_warn(0, "cannot read inport POS contents");
    return genom_serialization(self);
  }

  return genom_ok;
}



/* --- genom_loco_genom_state_write ------------------------------------- */

genom_event
genom_loco_genom_state_write(
  genom_context self)
{
  static struct genom_loco_genom_state_port *p;
  struct genom_loco_genom_state_ph *ph;
  STATUS s;
  char *b;
  size_t l;

  p = &self->data->self->ports.genom_state;

  ph = genom_loco_genom_state_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_outport(self);

  l = genom_serialen_t_genom_state_component(
    &(ph->buffer));
  if (l > ph->size || l + (1<<17) < ph->size) {
    s = posterIoctl(ph->id, FIO_RESIZE, &l);
    if (s != OK) {
      genom_log_warn(1, "cannot resize outport genom_state to %zu bytes", l);
      return genom_serialization(self);
    }
    ph->size = l;
  }

  s = posterTake(ph->id, POSTER_WRITE);
  if (s != OK) {
    genom_log_warn(1, "cannot access outport genom_state");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  genom_serialize_t_genom_state_component(
    &b, &(ph->buffer));
  s = posterGive(ph->id);
  if (s != OK) {
    genom_log_warn(1, "cannot flush outport genom_state");
    return genom_port_io(self);
  }

  return genom_ok;
}


/* --- genom_loco_genom_metadata_write ---------------------------------- */

genom_event
genom_loco_genom_metadata_write(
  genom_context self)
{
  static struct genom_loco_genom_metadata_port *p;
  struct genom_loco_genom_metadata_ph *ph;
  STATUS s;
  char *b;
  size_t l;

  p = &self->data->self->ports.genom_metadata;

  ph = genom_loco_genom_metadata_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_outport(self);

  l = genom_serialen_t_pocolibs_metadata_component(
    &(ph->buffer));
  if (l > ph->size || l + (1<<17) < ph->size) {
    s = posterIoctl(ph->id, FIO_RESIZE, &l);
    if (s != OK) {
      genom_log_warn(1, "cannot resize outport genom_metadata to %zu bytes", l);
      return genom_serialization(self);
    }
    ph->size = l;
  }

  s = posterTake(ph->id, POSTER_WRITE);
  if (s != OK) {
    genom_log_warn(1, "cannot access outport genom_metadata");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  genom_serialize_t_pocolibs_metadata_component(
    &b, &(ph->buffer));
  s = posterGive(ph->id);
  if (s != OK) {
    genom_log_warn(1, "cannot flush outport genom_metadata");
    return genom_port_io(self);
  }

  return genom_ok;
}


/* --- genom_loco_BAT_write --------------------------------------------- */

genom_event
genom_loco_BAT_write(
  genom_context self)
{
  static struct genom_loco_BAT_port *p;
  struct genom_loco_BAT_ph *ph;
  STATUS s;
  char *b;
  size_t l;

  p = &self->data->self->ports.BAT;

  ph = genom_loco_BAT_get_ph(p);
  if (!ph || !ph->id) return genom_no_such_outport(self);

  l = genom_serialen_t_loco_data(
    &(ph->buffer));
  if (l > ph->size || l + (1<<17) < ph->size) {
    s = posterIoctl(ph->id, FIO_RESIZE, &l);
    if (s != OK) {
      genom_log_warn(1, "cannot resize outport BAT to %zu bytes", l);
      return genom_serialization(self);
    }
    ph->size = l;
  }

  s = posterTake(ph->id, POSTER_WRITE);
  if (s != OK) {
    genom_log_warn(1, "cannot access outport BAT");
    return genom_port_io(self);
  }

  b = posterAddr(ph->id);
  genom_serialize_t_loco_data(
    &b, &(ph->buffer));
  s = posterGive(ph->id);
  if (s != OK) {
    genom_log_warn(1, "cannot flush outport BAT");
    return genom_port_io(self);
  }

  return genom_ok;
}


/* --- end of file --------------------------------------------------------- */
